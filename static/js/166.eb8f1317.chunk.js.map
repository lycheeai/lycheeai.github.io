{"version":3,"file":"static/js/166.eb8f1317.chunk.js","mappings":"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","sources":["../node_modules/@ensdomains/ensjs/dist/esm/functions/getProfile.js","../node_modules/@ensdomains/ensjs/dist/esm/utils/hexEncodedName.js","../node_modules/@ensdomains/ensjs/dist/esm/utils/validation.js","../node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral.js"],"sourcesContent":["import { formatsByName } from '@ensdomains/address-encoder';\nimport { ethers } from 'ethers';\nimport { decodeContenthash } from '../utils/contentHash';\nimport { hexEncodeName } from '../utils/hexEncodedName';\nimport { namehash } from '../utils/normalise';\nimport { parseInputType } from '../utils/validation';\nconst makeMulticallData = async ({ _getAddr, _getContentHash, _getText, resolverMulticallWrapper, }, name, options) => {\n    let calls = [];\n    options.texts &&\n        (calls = [\n            ...calls,\n            ...(await Promise.all(options.texts.map(async (x) => ({\n                key: x,\n                data: await _getText.raw(name, x),\n                type: 'text',\n            })))),\n        ]);\n    options.coinTypes &&\n        (calls = [\n            ...calls,\n            ...(await Promise.all(options.coinTypes.map(async (x) => ({\n                key: x,\n                data: await _getAddr.raw(name, x, true),\n                type: 'addr',\n            })))),\n        ]);\n    if (typeof options.contentHash === 'boolean' && options.contentHash) {\n        calls.push({\n            key: 'contentHash',\n            data: await _getContentHash.raw(name),\n            type: 'contenthash',\n        });\n    }\n    if (!calls.find((x) => x.key === '60')) {\n        calls.push({\n            key: '60',\n            data: await _getAddr.raw(name, '60', true),\n            type: 'addr',\n        });\n    }\n    const prRawData = await resolverMulticallWrapper.raw(calls.map((x) => x.data));\n    return { data: prRawData.data, calls };\n};\nconst fetchWithoutResolverMulticall = async ({ multicallWrapper }, calls, resolverAddress) => {\n    const callsWithResolver = calls.map((call) => ({\n        to: resolverAddress,\n        data: call.data.data,\n    }));\n    return (await multicallWrapper(callsWithResolver)).map((x) => x[1]);\n};\nconst getDataForName = async ({ contracts, _getAddr, _getContentHash, _getText, resolverMulticallWrapper, multicallWrapper, }, name, options, fallbackResolver, specificResolver) => {\n    const universalResolver = await contracts?.getUniversalResolver();\n    const { data, calls } = await makeMulticallData({ _getAddr, _getContentHash, _getText, resolverMulticallWrapper }, name, options);\n    let resolvedData;\n    let useFallbackResolver = false;\n    try {\n        if (specificResolver) {\n            const publicResolver = await contracts?.getPublicResolver(undefined, specificResolver);\n            resolvedData = await publicResolver?.callStatic.multicall(calls.map((x) => x.data));\n        }\n        else {\n            resolvedData = await universalResolver?.resolve(hexEncodeName(name), data);\n        }\n    }\n    catch {\n        useFallbackResolver = true;\n    }\n    let resolverAddress;\n    let recordData;\n    if (useFallbackResolver) {\n        resolverAddress = specificResolver || fallbackResolver;\n        recordData = await fetchWithoutResolverMulticall({ multicallWrapper }, calls, resolverAddress);\n    }\n    else {\n        resolverAddress = specificResolver || resolvedData['1'];\n        if (specificResolver) {\n            recordData = resolvedData;\n        }\n        else {\n            ;\n            [recordData] = await resolverMulticallWrapper.decode(resolvedData['0']);\n        }\n    }\n    const matchAddress = recordData[calls.findIndex((x) => x.key === '60')];\n    return {\n        address: matchAddress && (await _getAddr.decode(matchAddress)),\n        records: await formatRecords({ _getAddr, _getContentHash, _getText }, recordData, calls, options),\n        resolverAddress,\n    };\n};\nconst formatRecords = async ({ _getText, _getAddr, _getContentHash, }, data, calls, options) => {\n    let returnedRecords = (await Promise.all(data.map(async (item, i) => {\n        let decodedFromAbi;\n        let itemRet = {\n            key: calls[i].key,\n            type: calls[i].type,\n        };\n        if (itemRet.type === 'contenthash') {\n            decodedFromAbi = ethers.utils.defaultAbiCoder.decode(['bytes'], item)[0];\n            if (ethers.utils.hexStripZeros(decodedFromAbi) === '0x') {\n                return;\n            }\n        }\n        switch (calls[i].type) {\n            case 'text':\n                itemRet = {\n                    ...itemRet,\n                    value: await _getText.decode(item),\n                };\n                if (itemRet.value === '' || itemRet.value === undefined)\n                    return;\n                break;\n            case 'addr':\n                try {\n                    const addr = await _getAddr.decode(item, '', calls[i].key);\n                    if (addr) {\n                        itemRet = {\n                            ...itemRet,\n                            ...addr,\n                        };\n                        break;\n                    }\n                    else {\n                        return;\n                    }\n                }\n                catch {\n                    return;\n                }\n            case 'contenthash':\n                try {\n                    itemRet = {\n                        ...itemRet,\n                        value: await _getContentHash.decode(item),\n                    };\n                }\n                catch {\n                    return;\n                }\n        }\n        return itemRet;\n    })))\n        .filter((x) => {\n        return typeof x === 'object';\n    })\n        .filter((x) => x);\n    let returnedResponse = {};\n    if (typeof options.contentHash === 'string' ||\n        typeof options.contentHash === 'object') {\n        if (typeof options.contentHash === 'string' &&\n            ethers.utils.hexStripZeros(options.contentHash) === '0x') {\n            returnedResponse.contentHash = null;\n        }\n        else if (ethers.utils.isBytesLike(options.contentHash.decoded) &&\n            ethers.utils.hexStripZeros(options.contentHash.decoded) === '0x') {\n            returnedResponse.contentHash = null;\n        }\n        else {\n            returnedResponse.contentHash = options.contentHash;\n        }\n    }\n    else if (options.contentHash) {\n        const foundRecord = returnedRecords.find((item) => item.type === 'contenthash');\n        returnedResponse.contentHash = foundRecord ? foundRecord.value : null;\n    }\n    if (options.texts) {\n        returnedResponse.texts = returnedRecords.filter((x) => x.type === 'text');\n    }\n    if (options.coinTypes) {\n        returnedResponse.coinTypes = returnedRecords.filter((x) => x.type === 'addr');\n    }\n    return returnedResponse;\n};\nconst graphFetch = async ({ gqlInstance }, name, wantedRecords, resolverAddress) => {\n    const query = gqlInstance.gql `\n    query getRecords($id: String!) {\n      domain(id: $id) {\n        isMigrated\n        createdAt\n        resolver {\n          texts\n          coinTypes\n          contentHash\n          addr {\n            id\n          }\n          address\n        }\n      }\n    }\n  `;\n    const customResolverQuery = gqlInstance.gql `\n    query getRecordsWithCustomResolver($id: String!, $resolverId: String!) {\n      domain(id: $id) {\n        isMigrated\n        createdAt\n      }\n      resolver(id: $resolverId) {\n        texts\n        coinTypes\n        contentHash\n        addr {\n          id\n        }\n      }\n    }\n  `;\n    const client = gqlInstance.client;\n    const id = namehash(name);\n    let domain;\n    let resolverResponse;\n    if (!resolverAddress) {\n        ;\n        ({ domain } = await client.request(query, { id }));\n        resolverResponse = domain?.resolver;\n    }\n    else {\n        const resolverId = `${resolverAddress.toLowerCase()}-${id}`;\n        ({ resolver: resolverResponse, domain } = await client.request(customResolverQuery, { id, resolverId }));\n    }\n    if (!domain)\n        return;\n    const { isMigrated, createdAt } = domain;\n    let returnedRecords = {};\n    if (!resolverResponse)\n        return { isMigrated, createdAt };\n    if (!wantedRecords)\n        return {\n            isMigrated,\n            createdAt,\n            graphResolverAddress: resolverResponse.address || resolverAddress,\n        };\n    Object.keys(wantedRecords).forEach((key) => {\n        const data = wantedRecords[key];\n        if (typeof data === 'boolean' && data) {\n            if (key === 'contentHash') {\n                returnedRecords[key] = decodeContenthash(resolverResponse.contentHash);\n            }\n            else {\n                returnedRecords[key] = resolverResponse[key];\n            }\n        }\n    });\n    return {\n        ...returnedRecords,\n        isMigrated,\n        createdAt,\n        graphResolverAddress: resolverResponse.address || resolverAddress,\n    };\n};\nconst getProfileFromName = async ({ contracts, gqlInstance, _getAddr, _getContentHash, _getText, resolverMulticallWrapper, multicallWrapper, }, name, options) => {\n    const { resolverAddress, ..._options } = options || {};\n    const optsLength = Object.keys(_options).length;\n    const usingOptions = !optsLength || _options?.texts === true || _options?.coinTypes === true\n        ? optsLength\n            ? _options\n            : { contentHash: true, texts: true, coinTypes: true }\n        : undefined;\n    const graphResult = await graphFetch({ gqlInstance }, name, usingOptions, resolverAddress);\n    if (!graphResult)\n        return;\n    const { isMigrated, createdAt, graphResolverAddress, ...wantedRecords } = graphResult;\n    if (!graphResolverAddress && !options?.resolverAddress)\n        return { isMigrated, createdAt, message: \"Name doesn't have a resolver\" };\n    const result = await getDataForName({\n        contracts,\n        _getAddr,\n        _getContentHash,\n        _getText,\n        resolverMulticallWrapper,\n        multicallWrapper,\n    }, name, usingOptions ? wantedRecords : options, graphResolverAddress, options?.resolverAddress);\n    if (!result)\n        return { isMigrated, createdAt, message: \"Records fetch didn't complete\" };\n    return { ...result, isMigrated, createdAt, message: undefined };\n};\nconst getProfileFromAddress = async ({ contracts, gqlInstance, getName, _getAddr, _getContentHash, _getText, resolverMulticallWrapper, multicallWrapper, }, address, options) => {\n    let name;\n    try {\n        name = await getName(address);\n    }\n    catch (e) {\n        return;\n    }\n    if (!name || !name.name || name.name === '')\n        return;\n    if (!name.match)\n        return { ...name, isMigrated: null, createdAt: null };\n    const result = await getProfileFromName({\n        contracts,\n        gqlInstance,\n        _getAddr,\n        _getContentHash,\n        _getText,\n        resolverMulticallWrapper,\n        multicallWrapper,\n    }, name.name, options);\n    if (!result || result.message)\n        return;\n    delete result.address;\n    return {\n        ...result,\n        ...name,\n        message: undefined,\n    };\n};\nexport default async function ({ contracts, gqlInstance, getName, _getAddr, _getContentHash, _getText, resolverMulticallWrapper, multicallWrapper, }, nameOrAddress, options) {\n    if (options && options.coinTypes && typeof options.coinTypes !== 'boolean') {\n        options.coinTypes = options.coinTypes.map((coin) => {\n            if (!isNaN(parseInt(coin))) {\n                return coin;\n            }\n            else {\n                return `${formatsByName[coin.toUpperCase()].coinType}`;\n            }\n        });\n    }\n    const inputType = parseInputType(nameOrAddress);\n    if (inputType.type === 'unknown' || inputType.info === 'unsupported') {\n        throw new Error('Invalid input type');\n    }\n    if (inputType.type === 'address') {\n        return getProfileFromAddress({\n            contracts,\n            gqlInstance,\n            getName,\n            _getAddr,\n            _getContentHash,\n            _getText,\n            resolverMulticallWrapper,\n            multicallWrapper,\n        }, nameOrAddress, options);\n    }\n    return getProfileFromName({\n        contracts,\n        gqlInstance,\n        _getAddr,\n        _getContentHash,\n        _getText,\n        resolverMulticallWrapper,\n        multicallWrapper,\n    }, nameOrAddress, options);\n}\n","import packet from 'dns-packet';\nexport const hexEncodeName = (name) => `0x${packet.name.encode(name).toString('hex')}`;\n","import { isAddress } from 'ethers/lib/utils';\nimport { isEncodedLabelhash, saveName } from './labels';\nimport { normalise } from './normalise';\nexport const validateName = (name) => {\n    const nameArray = name.split('.');\n    const hasEmptyLabels = nameArray.some((label) => label.length == 0);\n    if (hasEmptyLabels)\n        throw new Error('Name cannot have empty labels');\n    const normalizedArray = nameArray.map((label) => {\n        if (label === '[root]') {\n            return label;\n        }\n        else {\n            return isEncodedLabelhash(label) ? label : normalise(label);\n        }\n    });\n    const normalizedName = normalizedArray.join('.');\n    saveName(normalizedName);\n    return normalizedName;\n};\nexport const validateTLD = (name) => {\n    const labels = name.split('.');\n    return validateName(labels[labels.length - 1]);\n};\nexport const parseInputType = (input) => {\n    const validTLD = validateTLD(input);\n    let regex = /[^.]+$/;\n    try {\n        validateName(input);\n    }\n    catch (e) {\n        return {\n            type: 'unknown',\n        };\n    }\n    if (input.indexOf('.') !== -1) {\n        const termArray = input.split('.');\n        const tld = input.match(regex) ? input.match(regex)[0] : '';\n        if (validTLD) {\n            if (tld === 'eth' && [...termArray[termArray.length - 2]].length < 3) {\n                // code-point length\n                return {\n                    type: 'name',\n                    info: 'short',\n                };\n            }\n            return {\n                type: 'name',\n                info: 'supported',\n            };\n        }\n        return {\n            type: 'name',\n            info: 'unsupported',\n        };\n    }\n    else if (isAddress(input)) {\n        return {\n            type: 'address',\n        };\n    }\n    else {\n        return {\n            type: 'label',\n        };\n    }\n};\n","export default function _taggedTemplateLiteral(strings, raw) {\n  if (!raw) {\n    raw = strings.slice(0);\n  }\n\n  return Object.freeze(Object.defineProperties(strings, {\n    raw: {\n      value: Object.freeze(raw)\n    }\n  }));\n}"],"names":["makeMulticallData","name","options","_getAddr","_getContentHash","_getText","resolverMulticallWrapper","calls","texts","Promise","all","map","x","raw","key","data","type","coinTypes","contentHash","push","find","prRawData","fetchWithoutResolverMulticall","resolverAddress","multicallWrapper","callsWithResolver","call","to","getDataForName","fallbackResolver","specificResolver","contracts","getUniversalResolver","universalResolver","useFallbackResolver","getPublicResolver","undefined","publicResolver","callStatic","multicall","resolvedData","resolve","hexEncodeName","recordData","decode","matchAddress","findIndex","formatRecords","address","records","item","i","itemRet","decodedFromAbi","ethers","value","addr","returnedRecords","filter","returnedResponse","decoded","foundRecord","graphFetch","wantedRecords","gqlInstance","query","gql","customResolverQuery","client","id","namehash","request","domain","resolverResponse","resolver","resolverId","toLowerCase","isMigrated","createdAt","graphResolverAddress","Object","keys","forEach","decodeContenthash","getProfileFromName","_options","optsLength","length","usingOptions","graphResult","message","result","getProfileFromAddress","getName","match","nameOrAddress","coin","isNaN","parseInt","formatsByName","toUpperCase","coinType","inputType","parseInputType","info","Error","packet","toString","validateName","nameArray","split","some","label","normalizedName","isEncodedLabelhash","normalise","join","saveName","input","validTLD","labels","validateTLD","regex","e","indexOf","termArray","tld","isAddress","_taggedTemplateLiteral","strings","slice","freeze","defineProperties"],"sourceRoot":""}