{"version":3,"file":"static/js/transferSubname.852b4368.chunk.js","mappings":"uQAGe,kBAAf,+B,8CAAe,aAAmDA,EAAnD,uGAAkBC,EAAlB,EAAkBA,UAAWC,EAA7B,EAA6BA,OAAQC,EAArC,EAAqCA,UAAsBC,EAA3D,EAA2DA,SAAUC,EAArE,EAAqEA,MAArE,EAA4EC,gBAAoBC,GAAhG,YACLC,EAASR,EAAKS,MAAM,KACpBC,EAAQF,EAAOG,QACfC,EAAYC,EAAAA,UAA+B,CAAC,UAAW,CAACH,IACxDI,GAAiBC,EAAAA,EAAAA,GAASP,EAAOQ,KAAK,MAJjC,KAKHZ,EALG,OAMF,aANE,OAUF,gBAVE,gDAOqBH,QAPrB,IAOqBA,OAPrB,EAOqBA,EAAWgB,cAPhC,eAOGC,EAPH,OAO+CC,QAAQjB,GAPvD,kBAQIgB,EAASE,oBAAoBC,gBAAgBP,EAAgBF,EAAWP,IAR5E,gCAWwBJ,QAXxB,IAWwBA,OAXxB,EAWwBA,EAAWqB,iBAXnC,eAWGC,EAXH,OAWqDJ,QAAQjB,GAX7D,WAYkBsB,EAAAA,EAAAA,GAAW,CAAErB,UAAAA,GAAaK,EAAOQ,KAAK,KAAM,WAAYT,EAAcA,EAAYkB,YAASC,GAZ7G,eAYGD,EAZH,yBAaIF,EAAYH,oBAAoBC,gBAAgBP,EAAgBJ,EAAOL,EAAO,IAAKoB,IAbvF,cAgBG,IAAIE,MAAJ,4BAA+BvB,IAhBlC,6C,kHCFFwB,EAAaC,EAAAA,GAAAA,KAAe,GAAGC,IAAI,IAAIC,IAAI,GAC3CP,EAAU,yCAAG,aAAsBxB,EAAMyB,GAA5B,iFAAStB,EAAT,EAASA,WAC3BsB,EADkB,sBAEdA,aAAkBO,MAFJ,yCAGPH,EAAAA,GAAAA,KAAeJ,EAAOQ,UAAY,MAH3B,YAKTR,aAAkBI,EAAAA,IALT,0CAMPJ,GANO,iCASPI,EAAAA,GAAAA,KAAeJ,IATR,oCAadzB,EAAKkC,SAAS,QAbA,kCAcY/B,EAAUH,GAdtB,mBAcRmC,EAdQ,kBAeTA,GAAAA,EAAaV,OAfJ,uBAgBJ,IAAIE,MAAM,qDAhBN,iCAiBPE,EAAAA,GAAAA,KAAeM,EAAYV,OAAOQ,UAAY,MAjBvC,iCAoBPL,GApBO,4CAAH,yD","sources":["../node_modules/@ensdomains/ensjs/dist/esm/functions/transferSubname.js","../node_modules/@ensdomains/ensjs/dist/esm/utils/wrapperExpiry.js"],"sourcesContent":["import { ethers } from 'ethers';\nimport { namehash } from '../utils/normalise';\nimport { makeExpiry } from '../utils/wrapperExpiry';\nexport default async function ({ contracts, signer, getExpiry, }, name, { contract, owner, resolverAddress, ...wrapperArgs }) {\n    const labels = name.split('.');\n    const label = labels.shift();\n    const labelhash = ethers.utils.solidityKeccak256(['string'], [label]);\n    const parentNodehash = namehash(labels.join('.'));\n    switch (contract) {\n        case 'registry': {\n            const registry = (await contracts?.getRegistry()).connect(signer);\n            return registry.populateTransaction.setSubnodeOwner(parentNodehash, labelhash, owner);\n        }\n        case 'nameWrapper': {\n            const nameWrapper = (await contracts?.getNameWrapper()).connect(signer);\n            const expiry = await makeExpiry({ getExpiry }, labels.join('.'), 'expiry' in wrapperArgs ? wrapperArgs.expiry : undefined);\n            return nameWrapper.populateTransaction.setSubnodeOwner(parentNodehash, label, owner, '0', expiry);\n        }\n        default: {\n            throw new Error(`Unknown contract: ${contract}`);\n        }\n    }\n}\n","import { BigNumber } from 'ethers';\nexport const MAX_EXPIRY = BigNumber.from(2).pow(64).sub(1);\nexport const makeExpiry = async ({ getExpiry }, name, expiry) => {\n    if (expiry) {\n        if (expiry instanceof Date) {\n            return BigNumber.from(expiry.getTime() / 1000);\n        }\n        else if (expiry instanceof BigNumber) {\n            return expiry;\n        }\n        else {\n            return BigNumber.from(expiry);\n        }\n    }\n    else {\n        if (name.endsWith('.eth')) {\n            const expResponse = await getExpiry(name);\n            if (!expResponse?.expiry)\n                throw new Error(\"Couldn't get expiry for name, please provide one.\");\n            return BigNumber.from(expResponse.expiry.getTime() / 1000);\n        }\n        else {\n            return MAX_EXPIRY;\n        }\n    }\n};\n"],"names":["name","contracts","signer","getExpiry","contract","owner","resolverAddress","wrapperArgs","labels","split","label","shift","labelhash","ethers","parentNodehash","namehash","join","getRegistry","registry","connect","populateTransaction","setSubnodeOwner","getNameWrapper","nameWrapper","makeExpiry","expiry","undefined","Error","MAX_EXPIRY","BigNumber","pow","sub","Date","getTime","endsWith","expResponse"],"sourceRoot":""}