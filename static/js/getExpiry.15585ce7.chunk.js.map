{"version":3,"file":"static/js/getExpiry.15585ce7.chunk.js","mappings":"yKAEMA,EAAkB,yCAAG,aAAwCC,GAAxC,uFAASC,EAAT,EAASA,UAAWC,EAApB,EAAoBA,mBACvCF,EAAOG,OAAS,GAAmB,QAAdH,EAAO,IADT,sBAEb,IAAII,MAAM,sDAFG,8BAIKH,QAJL,IAIKA,OAJL,EAIKA,EAAWI,mBAJhB,cAIjBC,EAJiB,OAKjBC,EAAaD,EAAcE,UAAUC,mBAAmB,cAAe,EACzEC,EAAAA,EAAAA,mBAAkB,CAAC,UAAW,CAACV,EAAO,OAEpCW,EAAkBL,EAAcE,UAAUC,mBAAmB,gBAR5C,kBAShBP,EAAiBU,IAAI,CACxB,CACIC,GAAIP,EAAcQ,QAClBC,KAAMR,GAEV,CACIM,GAAIP,EAAcQ,QAClBC,KAAMJ,MAhBS,2CAAH,wDAoBlBK,EAAgB,yCAAG,aAAsBhB,GAAtB,uFAASC,EAAT,EAASA,UAAT,gBACKA,QADL,IACKA,OADL,EACKA,EAAWgB,iBADhB,cACfC,EADe,OAEfX,EAAaW,EAAYV,UAAUC,mBAAmB,UAAW,EACnEU,EAAAA,EAAAA,GAASnB,EAAOoB,KAAK,QAHJ,kBAKd,CACHP,GAAIK,EAAYJ,QAChBC,KAAMR,IAPW,2CAAH,wDAUhBc,EAAmB,SAACC,EAAUtB,GAChC,OAAIsB,IAEkB,IAAlBtB,EAAOG,QAA8B,QAAdH,EAAO,GACvB,YAEJ,cACV,EACKY,EAAG,yCAAG,WAAOW,EAASC,GAAhB,sIAAqC,CAAC,EAAdF,EAAxB,EAAwBA,SAC1BtB,EAASwB,EAAKC,MAAM,KACpBC,EAAgBL,EAAiBC,EAAUtB,GAFzC,kBAGiB,gBAAlB0B,EACDV,EAAiBO,EAASvB,GAC1BD,EAAmBwB,EAASvB,IAL1B,2CAAH,wDAOH2B,EAAqB,yCAAG,aAAwCZ,GAAxC,qGAASd,EAAT,EAASA,UAAWC,EAApB,EAAoBA,iBAApB,SACLA,EAAiB0B,OAAOb,GADnB,cACpBc,EADoB,uBAEE5B,QAFF,IAEEA,OAFF,EAEEA,EAAWI,mBAFb,cAEpBC,EAFoB,kBAIAA,EAAcE,UAAUsB,qBAAqB,cAAeD,EAAO,GAAGE,YAJtE,eAIfC,EAJe,OAKA1B,EAAcE,UAAUsB,qBAAqB,eAAgBD,EAAO,GAAGE,YALvE,eAKfE,EALe,uBAMf,CACHC,OAAQF,EAAc,EAAI,IAAIG,KAAmB,IAAdH,GAAsB,KACzDC,YAAsC,IAAzBA,EAAYG,aARP,sHAAH,wDAerBC,EAAmB,yCAAG,aAAsBtB,GAAtB,2FAASd,EAAT,EAASA,UAAT,gBACEA,QADF,IACEA,OADF,EACEA,EAAWgB,iBADb,cAClBC,EADkB,kBAGaA,EAAYV,UAAUsB,qBAAqB,UAAWf,GAHnE,yBAGGmB,EAHH,uBAIb,CACHA,OAAQ,IAAIC,KAAc,IAATD,GACjBD,YAAa,OANG,mHAAH,wDAanBL,EAAM,yCAAG,WAAOL,EAASR,EAAMS,GAAtB,kIAA2C,CAAC,EAAdF,EAA9B,EAA8BA,SAC5B,OAATP,EADO,wDAGLf,EAASwB,EAAKC,MAAM,KACpBC,EAAgBL,EAAiBC,EAAUtB,GAJtC,kBAKc,gBAAlB0B,EACDW,EAAoBd,EAASR,GAC7BY,EAAsBJ,EAASR,IAP1B,2CAAH,0DASZ,WACIH,IAAAA,EACAgB,OAAAA,E","sources":["../node_modules/@ensdomains/ensjs/dist/esm/functions/getExpiry.js"],"sourcesContent":["import { solidityKeccak256 } from 'ethers/lib/utils';\nimport { namehash } from '../utils/normalise';\nconst getRegistrarExpiry = async ({ contracts, multicallWrapper }, labels) => {\n    if (labels.length > 2 || labels[1] !== 'eth') {\n        throw new Error('Only .eth names have expiry dates on the registrar');\n    }\n    const baseRegistrar = await contracts?.getBaseRegistrar();\n    const expiryCall = baseRegistrar.interface.encodeFunctionData('nameExpires', [\n        solidityKeccak256(['string'], [labels[0]]),\n    ]);\n    const gracePeriodCall = baseRegistrar.interface.encodeFunctionData('GRACE_PERIOD');\n    return multicallWrapper.raw([\n        {\n            to: baseRegistrar.address,\n            data: expiryCall,\n        },\n        {\n            to: baseRegistrar.address,\n            data: gracePeriodCall,\n        },\n    ]);\n};\nconst getWrapperExpiry = async ({ contracts }, labels) => {\n    const nameWrapper = await contracts?.getNameWrapper();\n    const expiryCall = nameWrapper.interface.encodeFunctionData('getData', [\n        namehash(labels.join('.')),\n    ]);\n    return {\n        to: nameWrapper.address,\n        data: expiryCall,\n    };\n};\nconst getContractToUse = (contract, labels) => {\n    if (contract)\n        return contract;\n    if (labels.length === 2 && labels[1] === 'eth') {\n        return 'registrar';\n    }\n    return 'nameWrapper';\n};\nconst raw = async (ensArgs, name, { contract } = {}) => {\n    const labels = name.split('.');\n    const contractToUse = getContractToUse(contract, labels);\n    return contractToUse === 'nameWrapper'\n        ? getWrapperExpiry(ensArgs, labels)\n        : getRegistrarExpiry(ensArgs, labels);\n};\nconst decodeRegistrarExpiry = async ({ contracts, multicallWrapper }, data) => {\n    const result = await multicallWrapper.decode(data);\n    const baseRegistrar = await contracts?.getBaseRegistrar();\n    try {\n        const [nameExpires] = baseRegistrar.interface.decodeFunctionResult('nameExpires', result[0].returnData);\n        const [gracePeriod] = baseRegistrar.interface.decodeFunctionResult('GRACE_PERIOD', result[1].returnData);\n        return {\n            expiry: nameExpires > 0 ? new Date(nameExpires * 1000) : null,\n            gracePeriod: gracePeriod.toNumber() * 1000,\n        };\n    }\n    catch {\n        return;\n    }\n};\nconst decodeWrapperExpiry = async ({ contracts }, data) => {\n    const nameWrapper = await contracts?.getNameWrapper();\n    try {\n        const [_owner, _fuses, expiry] = nameWrapper.interface.decodeFunctionResult('getData', data);\n        return {\n            expiry: new Date(expiry * 1000),\n            gracePeriod: null,\n        };\n    }\n    catch {\n        return;\n    }\n};\nconst decode = async (ensArgs, data, name, { contract } = {}) => {\n    if (data === null)\n        return;\n    const labels = name.split('.');\n    const contractToUse = getContractToUse(contract, labels);\n    return contractToUse === 'nameWrapper'\n        ? decodeWrapperExpiry(ensArgs, data)\n        : decodeRegistrarExpiry(ensArgs, data);\n};\nexport default {\n    raw,\n    decode,\n};\n"],"names":["getRegistrarExpiry","labels","contracts","multicallWrapper","length","Error","getBaseRegistrar","baseRegistrar","expiryCall","interface","encodeFunctionData","solidityKeccak256","gracePeriodCall","raw","to","address","data","getWrapperExpiry","getNameWrapper","nameWrapper","namehash","join","getContractToUse","contract","ensArgs","name","split","contractToUse","decodeRegistrarExpiry","decode","result","decodeFunctionResult","returnData","nameExpires","gracePeriod","expiry","Date","toNumber","decodeWrapperExpiry"],"sourceRoot":""}