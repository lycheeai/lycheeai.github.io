{"version":3,"file":"static/js/commitName.87d582fa.chunk.js","mappings":"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","sources":["../node_modules/@ensdomains/ensjs/dist/esm/functions/commitName.js","../node_modules/@ensdomains/ensjs/dist/esm/utils/generateFuseInput.js","../node_modules/@ensdomains/ensjs/dist/esm/utils/recordHelpers.js","../node_modules/@ensdomains/ensjs/dist/esm/utils/registerHelpers.js"],"sourcesContent":["import { makeCommitment } from '../utils/registerHelpers';\nexport default async function ({ contracts }, name, { resolverAddress, ...params }) {\n    const labels = name.split('.');\n    if (labels.length !== 2 || labels[1] !== 'eth')\n        throw new Error('Currently only .eth TLD registrations are supported');\n    const controller = await contracts.getEthRegistrarController();\n    const resolver = await contracts.getPublicResolver(undefined, resolverAddress);\n    const { secret, commitment, wrapperExpiry } = makeCommitment({\n        name,\n        resolver,\n        ...params,\n    });\n    return {\n        ...(await controller.populateTransaction.commit(commitment)),\n        customData: {\n            secret,\n            commitment,\n            wrapperExpiry,\n        },\n    };\n}\n","import { ethers } from 'ethers';\nimport fuses from './fuses';\nexport default (fuseOptions) => {\n    const fuseKeys = Object.keys(fuseOptions)\n        .filter((opt) => fuseOptions[opt] === true)\n        .map((opt) => opt\n        .split(/(?=[A-Z])/)\n        .join('_')\n        .toUpperCase());\n    const bigNumberFuses = fuseKeys.reduce((prev, curr) => {\n        return prev.or(fuses[curr]);\n    }, ethers.BigNumber.from(0));\n    return bigNumberFuses.toHexString();\n};\n","import { formatsByCoinType, formatsByName } from '@ensdomains/address-encoder';\nimport { encodeContenthash } from './contentHash';\nexport const generateSetAddr = (namehash, coinType, address, resolver) => {\n    let coinTypeInstance;\n    if (!isNaN(parseInt(coinType))) {\n        coinTypeInstance = formatsByCoinType[parseInt(coinType)];\n    }\n    else {\n        coinTypeInstance = formatsByName[coinType.toUpperCase()];\n    }\n    const inputCoinType = coinTypeInstance.coinType;\n    const encodedAddress = coinTypeInstance.decoder(address);\n    return resolver?.interface.encodeFunctionData('setAddr(bytes32,uint256,bytes)', [namehash, inputCoinType, encodedAddress]);\n};\nexport function generateSingleRecordCall(namehash, resolver, type) {\n    if (type === 'contentHash') {\n        return (_r) => {\n            const record = _r;\n            let _contentHash = '';\n            if (record !== _contentHash) {\n                const encoded = encodeContenthash(record);\n                if (encoded.error)\n                    throw new Error(encoded.error);\n                _contentHash = encoded.encoded;\n            }\n            return resolver.interface.encodeFunctionData('setContenthash', [\n                namehash,\n                _contentHash,\n            ]);\n        };\n    }\n    else {\n        return (_r) => {\n            const record = _r;\n            if (type === 'text') {\n                return resolver.interface.encodeFunctionData('setText', [\n                    namehash,\n                    record.key,\n                    record.value,\n                ]);\n            }\n            else {\n                return generateSetAddr(namehash, record.key, record.value, resolver);\n            }\n        };\n    }\n}\nexport const generateRecordCallArray = (namehash, records, resolver) => {\n    const calls = [];\n    if (records.contentHash) {\n        const data = generateSingleRecordCall(namehash, resolver, 'contentHash')(records.contentHash);\n        data && calls.push(data);\n    }\n    if (records.texts && records.texts.length > 0) {\n        records.texts\n            .map(generateSingleRecordCall(namehash, resolver, 'text'))\n            .forEach((call) => calls.push(call));\n    }\n    if (records.coinTypes && records.coinTypes.length > 0) {\n        records.coinTypes\n            .map(generateSingleRecordCall(namehash, resolver, 'addr'))\n            .forEach((call) => calls.push(call));\n    }\n    return calls;\n};\n","import { utils } from 'ethers';\nimport generateFuseInput from './generateFuseInput';\nimport { labelhash } from './labels';\nimport { namehash } from './normalise';\nimport { generateRecordCallArray } from './recordHelpers';\nexport const randomSecret = () => {\n    const bytes = Buffer.allocUnsafe(32);\n    return '0x' + crypto.getRandomValues(bytes).toString('hex');\n};\nexport const makeCommitmentData = ({ name, owner, duration, resolver, records, reverseRecord, fuses, wrapperExpiry, secret, }) => {\n    const label = labelhash(name.split('.')[0]);\n    const hash = namehash(name);\n    const resolverAddress = resolver.address;\n    const fuseData = fuses ? generateFuseInput(fuses) : '0';\n    if (reverseRecord) {\n        if (!records) {\n            records = { coinTypes: [{ key: 'ETH', value: owner }] };\n        }\n        else if (!records.coinTypes?.find((c) => c.key === 'ETH')) {\n            if (!records.coinTypes)\n                records.coinTypes = [];\n            records.coinTypes.push({ key: 'ETH', value: owner });\n        }\n    }\n    const data = records ? generateRecordCallArray(hash, records, resolver) : [];\n    return [\n        label,\n        owner,\n        duration,\n        resolverAddress,\n        data,\n        secret,\n        !!reverseRecord,\n        fuseData,\n        wrapperExpiry || Math.floor(Date.now() / 1000) + duration,\n    ];\n};\nexport const makeRegistrationData = (params) => {\n    const commitmentData = makeCommitmentData(params);\n    commitmentData[0] = params.name.split('.')[0];\n    const secret = commitmentData.splice(5, 1)[0];\n    commitmentData.splice(3, 0, secret);\n    return commitmentData;\n};\nexport const makeCommitment = ({ secret = randomSecret(), ...inputParams }) => {\n    const generatedParams = makeCommitmentData({\n        ...inputParams,\n        secret,\n    });\n    const commitment = _makeCommitment(generatedParams);\n    return {\n        secret,\n        commitment,\n        wrapperExpiry: generatedParams[8],\n    };\n};\nexport const _makeCommitment = (params) => {\n    return utils.keccak256(utils.defaultAbiCoder.encode([\n        'bytes32',\n        'address',\n        'uint256',\n        'address',\n        'bytes[]',\n        'bytes32',\n        'bool',\n        'uint32',\n        'uint64',\n    ], params));\n};\n"],"names":["name","contracts","resolverAddress","params","labels","split","length","Error","getEthRegistrarController","controller","getPublicResolver","undefined","resolver","makeCommitment","secret","commitment","wrapperExpiry","populateTransaction","commit","customData","fuseOptions","Object","keys","filter","opt","map","join","toUpperCase","reduce","prev","curr","or","fuses","ethers","toHexString","generateSingleRecordCall","namehash","type","_r","record","_contentHash","encoded","encodeContenthash","error","interface","encodeFunctionData","key","value","coinType","address","coinTypeInstance","inputCoinType","isNaN","parseInt","formatsByName","formatsByCoinType","encodedAddress","decoder","generateSetAddr","generateRecordCallArray","records","calls","contentHash","data","push","texts","forEach","call","coinTypes","makeCommitmentData","owner","duration","reverseRecord","label","labelhash","hash","fuseData","generateFuseInput","find","c","Math","floor","Date","now","makeRegistrationData","commitmentData","splice","bytes","Buffer","allocUnsafe","crypto","getRandomValues","toString","randomSecret","inputParams","generatedParams","_makeCommitment","utils"],"sourceRoot":""}