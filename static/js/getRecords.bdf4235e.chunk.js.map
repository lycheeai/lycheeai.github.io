{"version":3,"file":"static/js/getRecords.bdf4235e.chunk.js","mappings":"4LACe,kBAAf,+B,8CAAe,aAAgCA,EAAMC,GAAtC,iFAAkBC,EAAlB,EAAkBA,WAEN,UADjBC,GAAYC,EAAAA,EAAAA,IAAeJ,IACnBK,MAAsC,UAAnBF,EAAUE,KAFhC,sBAGD,IAAIC,MAAM,6BAHT,uBAKEJ,EAAWF,EAAMC,GALnB,oF,0HCEFM,EAAe,SAACP,GACzB,IAAMQ,EAAYR,EAAKS,MAAM,KAE7B,GADuBD,EAAUE,MAAK,SAACC,GAAD,OAA2B,GAAhBA,EAAMC,MAAjB,IAElC,MAAM,IAAIN,MAAM,iCACpB,IAQMO,EARkBL,EAAUM,KAAI,SAACH,GACnC,MAAc,WAAVA,IAIOI,EAAAA,EAAAA,IAAmBJ,GAHnBA,GAGoCK,EAAAA,EAAAA,GAAUL,EAE5D,IACsCM,KAAK,KAE5C,OADAC,EAAAA,EAAAA,IAASL,GACFA,CACV,EAKYT,EAAiB,SAACe,GAC3B,IAAMC,EALiB,SAACpB,GACxB,IAAMqB,EAASrB,EAAKS,MAAM,KAC1B,OAAOF,EAAac,EAAOA,EAAOT,OAAS,GAC9C,CAEoBU,CAAYH,GACzBI,EAAQ,SACZ,IACIhB,EAAaY,EAMhB,CAJD,MAAOK,GACH,MAAO,CACHnB,KAAM,UAEb,CACD,IAA4B,IAAxBc,EAAMM,QAAQ,KAAa,CAC3B,IAAMC,EAAYP,EAAMV,MAAM,KACxBkB,EAAMR,EAAMS,MAAML,GAASJ,EAAMS,MAAML,GAAO,GAAK,GACzD,OAAIH,EACY,QAARO,IAAiB,OAAID,EAAUA,EAAUd,OAAS,IAAIA,OAAS,EAExD,CACHP,KAAM,OACNwB,KAAM,SAGP,CACHxB,KAAM,OACNwB,KAAM,aAGP,CACHxB,KAAM,OACNwB,KAAM,cAEb,CACI,OAAIC,EAAAA,EAAAA,WAAUX,GACR,CACHd,KAAM,WAIH,CACHA,KAAM,QAGjB,C","sources":["../node_modules/@ensdomains/ensjs/dist/esm/functions/getRecords.js","../node_modules/@ensdomains/ensjs/dist/esm/utils/validation.js"],"sourcesContent":["import { parseInputType } from '../utils/validation';\nexport default async function ({ getProfile }, name, options) {\n    const inputType = parseInputType(name);\n    if (inputType.type !== 'name' && inputType.type !== 'label') {\n        throw new Error('Input must be an ENS name');\n    }\n    return await getProfile(name, options);\n}\n","import { isAddress } from 'ethers/lib/utils';\nimport { isEncodedLabelhash, saveName } from './labels';\nimport { normalise } from './normalise';\nexport const validateName = (name) => {\n    const nameArray = name.split('.');\n    const hasEmptyLabels = nameArray.some((label) => label.length == 0);\n    if (hasEmptyLabels)\n        throw new Error('Name cannot have empty labels');\n    const normalizedArray = nameArray.map((label) => {\n        if (label === '[root]') {\n            return label;\n        }\n        else {\n            return isEncodedLabelhash(label) ? label : normalise(label);\n        }\n    });\n    const normalizedName = normalizedArray.join('.');\n    saveName(normalizedName);\n    return normalizedName;\n};\nexport const validateTLD = (name) => {\n    const labels = name.split('.');\n    return validateName(labels[labels.length - 1]);\n};\nexport const parseInputType = (input) => {\n    const validTLD = validateTLD(input);\n    let regex = /[^.]+$/;\n    try {\n        validateName(input);\n    }\n    catch (e) {\n        return {\n            type: 'unknown',\n        };\n    }\n    if (input.indexOf('.') !== -1) {\n        const termArray = input.split('.');\n        const tld = input.match(regex) ? input.match(regex)[0] : '';\n        if (validTLD) {\n            if (tld === 'eth' && [...termArray[termArray.length - 2]].length < 3) {\n                // code-point length\n                return {\n                    type: 'name',\n                    info: 'short',\n                };\n            }\n            return {\n                type: 'name',\n                info: 'supported',\n            };\n        }\n        return {\n            type: 'name',\n            info: 'unsupported',\n        };\n    }\n    else if (isAddress(input)) {\n        return {\n            type: 'address',\n        };\n    }\n    else {\n        return {\n            type: 'label',\n        };\n    }\n};\n"],"names":["name","options","getProfile","inputType","parseInputType","type","Error","validateName","nameArray","split","some","label","length","normalizedName","map","isEncodedLabelhash","normalise","join","saveName","input","validTLD","labels","validateTLD","regex","e","indexOf","termArray","tld","match","info","isAddress"],"sourceRoot":""}