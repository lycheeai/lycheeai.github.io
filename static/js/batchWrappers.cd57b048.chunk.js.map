{"version":3,"file":"static/js/batchWrappers.cd57b048.chunk.js","mappings":"wSACaA,EAAmB,CAC5BC,IAAK,WAAF,8BAAE,aAAsBC,EAAMC,GAA5B,qFAASC,EAAT,EAASA,UAAT,gBAC+BA,QAD/B,IAC+BA,OAD/B,EAC+BA,EAAWC,uBAD1C,cACKC,EADL,yBAEM,CACHC,GAAID,EAAkBE,QACtBL,KAAMG,EAAkBG,UAAUC,mBAAmB,UAAW,EAC5DC,EAAAA,EAAAA,GAAcT,GACdC,MANP,2CAAF,uDAAE,GAULS,OAAQ,WAAF,8BAAE,aAAsBT,GAAtB,uFAASC,EAAT,EAASA,UAAT,gBAC4BA,QAD5B,IAC4BA,OAD5B,EAC4BA,EAAWC,uBADvC,UACEC,EADF,QAEEO,EAAWP,EAAkBG,UAAUK,qBAAqB,UAAWX,KAC3DU,EAAS,GAHvB,0EAMG,CAAEV,KAAMU,EAAS,GAAIE,SAAUF,EAAS,KAN3C,2CAAF,qDAAE,IASCG,EAA2B,CACpCf,IAAK,WAAF,8BAAE,aAAsBE,GAAtB,uFAASC,EAAT,EAASA,UAAT,gBAC4BA,QAD5B,IAC4BA,OAD5B,EAC4BA,EAAWa,oBADvC,cACKC,EADL,OAEKC,EAAmBhB,EAAKiB,KAAI,SAACC,GAAD,OAAUA,EAAKlB,IAAf,IAFjC,kBAGM,CACHI,GAAIW,EAAeV,QACnBL,KAAMe,EAAeT,UAAUC,mBAAmB,YAAa,CAC3DS,MANP,2CAAF,qDAAE,GAULP,OAAQ,WAAF,8BAAE,aAAsBT,GAAtB,uFAASC,EAAT,EAASA,UAAT,gBACyBA,QADzB,IACyBA,OADzB,EACyBA,EAAWa,oBADpC,UACEC,EADF,OAEEL,EAAWK,EAAeT,UAAUK,qBAAqB,YAAaX,GAFxE,0EAMGU,GANH,2CAAF,qDAAE,IASCS,EAAmB,CAC5BrB,IAAK,WAAF,8BAAE,aAA+BsB,GAA/B,mGAAkBnB,EAAlB,EAAkBA,UAA2BoB,EAA7C,gDACuBpB,QADvB,IACuBA,OADvB,EACuBA,EAAWqB,eADlC,cACKC,EADL,yBAEM,CACHnB,GAAImB,EAAUlB,QACdL,KAAMuB,EAAUjB,UAAUC,mBAAmB,eAAgB,CACzDc,EACAD,EAAaH,KAAI,SAACO,GAAD,MAAS,CACtBC,OAAQD,EAAGpB,GACXsB,SAAUF,EAAGxB,KAFA,QANxB,2CAAF,qDAAE,GAaLS,OAAQ,WAAF,8BAAE,aAA+BT,GAA/B,uFAAkBC,EAAlB,EAAkBA,UACjBD,EADD,wEAGoBC,QAHpB,IAGoBA,OAHpB,EAGoBA,EAAWqB,eAH/B,cAGEC,EAHF,kBAKiBA,EAAUjB,UAAUK,qBAAqB,eAAgBX,GAL1E,eAKO2B,EALP,uBAMOA,GANP,sHAAF,qDAAE,G,uECtDCnB,EAAgB,SAACT,GAAD,kBAAe6B,EAAAA,KAAAA,OAAmB7B,GAAM8B,SAAS,OAAjD,C","sources":["../node_modules/@ensdomains/ensjs/dist/esm/functions/batchWrappers.js","../node_modules/@ensdomains/ensjs/dist/esm/utils/hexEncodedName.js"],"sourcesContent":["import { hexEncodeName } from '../utils/hexEncodedName';\nexport const universalWrapper = {\n    raw: async ({ contracts }, name, data) => {\n        const universalResolver = await contracts?.getUniversalResolver();\n        return {\n            to: universalResolver.address,\n            data: universalResolver.interface.encodeFunctionData('resolve', [\n                hexEncodeName(name),\n                data,\n            ]),\n        };\n    },\n    decode: async ({ contracts }, data) => {\n        const universalResolver = await contracts?.getUniversalResolver();\n        const response = universalResolver.interface.decodeFunctionResult('resolve', data);\n        if (!response || !response[0]) {\n            return;\n        }\n        return { data: response[0], resolver: response[1] };\n    },\n};\nexport const resolverMulticallWrapper = {\n    raw: async ({ contracts }, data) => {\n        const publicResolver = await contracts?.getPublicResolver();\n        const formattedDataArr = data.map((item) => item.data);\n        return {\n            to: publicResolver.address,\n            data: publicResolver.interface.encodeFunctionData('multicall', [\n                formattedDataArr,\n            ]),\n        };\n    },\n    decode: async ({ contracts }, data) => {\n        const publicResolver = await contracts?.getPublicResolver();\n        const response = publicResolver.interface.decodeFunctionResult('multicall', data);\n        if (!response) {\n            return;\n        }\n        return response;\n    },\n};\nexport const multicallWrapper = {\n    raw: async function ({ contracts }, transactions, requireSuccess = false) {\n        const multicall = await contracts?.getMulticall();\n        return {\n            to: multicall.address,\n            data: multicall.interface.encodeFunctionData('tryAggregate', [\n                requireSuccess,\n                transactions.map((tx) => ({\n                    target: tx.to,\n                    callData: tx.data,\n                })),\n            ]),\n        };\n    },\n    decode: async function ({ contracts }, data) {\n        if (!data)\n            return;\n        const multicall = await contracts?.getMulticall();\n        try {\n            const [result] = multicall.interface.decodeFunctionResult('tryAggregate', data);\n            return result;\n        }\n        catch {\n            return;\n        }\n    },\n};\n","import packet from 'dns-packet';\nexport const hexEncodeName = (name) => `0x${packet.name.encode(name).toString('hex')}`;\n"],"names":["universalWrapper","raw","name","data","contracts","getUniversalResolver","universalResolver","to","address","interface","encodeFunctionData","hexEncodeName","decode","response","decodeFunctionResult","resolver","resolverMulticallWrapper","getPublicResolver","publicResolver","formattedDataArr","map","item","multicallWrapper","transactions","requireSuccess","getMulticall","multicall","tx","target","callData","result","packet","toString"],"sourceRoot":""}