{"version":3,"file":"static/js/createSubname.a3faf2d3.chunk.js","mappings":"oRAIe,kBAAf,+B,8CAAe,aAAmDA,EAAnD,8GAAkBC,EAAlB,EAAkBA,UAAWC,EAA7B,EAA6BA,OAAQC,EAArC,EAAqCA,UAAsBC,EAA3D,EAA2DA,MAAOC,EAAlE,EAAkEA,gBAAiBC,EAAnF,EAAmFA,SAAaC,GAAhG,YAEW,KADhBC,EAASR,EAAKS,MAAM,MACfC,OAFA,sBAGD,IAAIC,MAAM,6DAHT,YAKP,UAAWJ,IAA4B,aAAbD,EALnB,sBAMD,IAAIK,MAAM,2CANT,UAQNN,EARM,yCASkBJ,QATlB,IASkBA,OATlB,EASkBA,EAAWW,oBAT7B,QASPP,EATO,OASkDQ,QATlD,QAWLC,EAAQN,EAAOO,QACfC,EAAYC,EAAAA,UAA+B,CAAC,UAAW,CAACH,IACxDI,GAAiBC,EAAAA,EAAAA,GAASX,EAAOY,KAAK,MAbjC,KAcHd,EAdG,OAeF,aAfE,QAmBF,gBAnBE,iDAgBqBL,QAhBrB,IAgBqBA,OAhBrB,EAgBqBA,EAAWoB,cAhBhC,eAgBGC,EAhBH,OAgB+CC,QAAQrB,GAhBvD,kBAiBIoB,EAASE,oBAAoBC,iBAAiBP,EAAgBF,EAAWZ,EAAOC,EAAiB,IAjBrG,gCAoBwBJ,QApBxB,IAoBwBA,OApBxB,EAoBwBA,EAAWyB,iBApBnC,eAoBGC,EApBH,OAoBqDJ,QAAQrB,GApB7D,WAqBkB0B,EAAAA,EAAAA,GAAW,CAAEzB,UAAAA,GAAaH,EAAM,WAAYO,EAAcA,EAAYsB,YAASC,GArBjG,eAqBGD,EArBH,OAsBGE,EAAiB,UAAWxB,GAAeA,EAAYyB,OACvDC,EAAAA,EAAAA,GAAkB1B,EAAYyB,OAC9B,IAxBH,kBAyBIL,EAAYH,oBAAoBC,iBAAiBP,EAAgBJ,EAAOV,EAAOC,EAAiB,EAAG0B,EAAgBF,IAzBvH,cA4BG,IAAIlB,MAAJ,4BAA+BL,IA5BlC,6C,sECFf,aAAgB4B,GAUZ,OATiBC,OAAOC,KAAKF,GACxBG,QAAO,SAACC,GAAD,OAA8B,IAArBJ,EAAYI,EAArB,IACPC,KAAI,SAACD,GAAD,OAASA,EACb7B,MAAM,aACNW,KAAK,KACLoB,aAHI,IAIuBC,QAAO,SAACC,EAAMC,GAC1C,OAAOD,EAAKE,GAAGZ,EAAAA,GAAMW,GACxB,GAAE1B,EAAAA,GAAAA,KAAsB,IACH4B,aAV1B,C,4FCDaC,EAAaC,EAAAA,GAAAA,KAAe,GAAGC,IAAI,IAAIC,IAAI,GAC3CrB,EAAU,yCAAG,aAAsB5B,EAAM6B,GAA5B,iFAAS1B,EAAT,EAASA,WAC3B0B,EADkB,sBAEdA,aAAkBqB,MAFJ,yCAGPH,EAAAA,GAAAA,KAAelB,EAAOsB,UAAY,MAH3B,YAKTtB,aAAkBkB,EAAAA,IALT,0CAMPlB,GANO,iCASPkB,EAAAA,GAAAA,KAAelB,IATR,oCAad7B,EAAKoD,SAAS,QAbA,kCAcYjD,EAAUH,GAdtB,mBAcRqD,EAdQ,kBAeTA,GAAAA,EAAaxB,OAfJ,uBAgBJ,IAAIlB,MAAM,qDAhBN,iCAiBPoC,EAAAA,GAAAA,KAAeM,EAAYxB,OAAOsB,UAAY,MAjBvC,iCAoBPL,GApBO,4CAAH,yD","sources":["../node_modules/@ensdomains/ensjs/dist/esm/functions/createSubname.js","../node_modules/@ensdomains/ensjs/dist/esm/utils/generateFuseInput.js","../node_modules/@ensdomains/ensjs/dist/esm/utils/wrapperExpiry.js"],"sourcesContent":["import { ethers } from 'ethers';\nimport generateFuseInput from '../utils/generateFuseInput';\nimport { namehash } from '../utils/normalise';\nimport { makeExpiry } from '../utils/wrapperExpiry';\nexport default async function ({ contracts, signer, getExpiry, }, name, { owner, resolverAddress, contract, ...wrapperArgs }) {\n    const labels = name.split('.');\n    if (labels.length === 1) {\n        throw new Error('Subnames in ENS.js can only be created for 2LDs, not TLDs');\n    }\n    if ('fuses' in wrapperArgs && contract === 'registry') {\n        throw new Error('Fuses can only be set on a wrapped name');\n    }\n    if (!resolverAddress) {\n        resolverAddress = (await contracts?.getPublicResolver()).address;\n    }\n    const label = labels.shift();\n    const labelhash = ethers.utils.solidityKeccak256(['string'], [label]);\n    const parentNodehash = namehash(labels.join('.'));\n    switch (contract) {\n        case 'registry': {\n            const registry = (await contracts?.getRegistry()).connect(signer);\n            return registry.populateTransaction.setSubnodeRecord(parentNodehash, labelhash, owner, resolverAddress, 0);\n        }\n        case 'nameWrapper': {\n            const nameWrapper = (await contracts?.getNameWrapper()).connect(signer);\n            const expiry = await makeExpiry({ getExpiry }, name, 'expiry' in wrapperArgs ? wrapperArgs.expiry : undefined);\n            const generatedFuses = 'fuses' in wrapperArgs && wrapperArgs.fuses\n                ? generateFuseInput(wrapperArgs.fuses)\n                : '0';\n            return nameWrapper.populateTransaction.setSubnodeRecord(parentNodehash, label, owner, resolverAddress, 0, generatedFuses, expiry);\n        }\n        default: {\n            throw new Error(`Unknown contract: ${contract}`);\n        }\n    }\n}\n","import { ethers } from 'ethers';\nimport fuses from './fuses';\nexport default (fuseOptions) => {\n    const fuseKeys = Object.keys(fuseOptions)\n        .filter((opt) => fuseOptions[opt] === true)\n        .map((opt) => opt\n        .split(/(?=[A-Z])/)\n        .join('_')\n        .toUpperCase());\n    const bigNumberFuses = fuseKeys.reduce((prev, curr) => {\n        return prev.or(fuses[curr]);\n    }, ethers.BigNumber.from(0));\n    return bigNumberFuses.toHexString();\n};\n","import { BigNumber } from 'ethers';\nexport const MAX_EXPIRY = BigNumber.from(2).pow(64).sub(1);\nexport const makeExpiry = async ({ getExpiry }, name, expiry) => {\n    if (expiry) {\n        if (expiry instanceof Date) {\n            return BigNumber.from(expiry.getTime() / 1000);\n        }\n        else if (expiry instanceof BigNumber) {\n            return expiry;\n        }\n        else {\n            return BigNumber.from(expiry);\n        }\n    }\n    else {\n        if (name.endsWith('.eth')) {\n            const expResponse = await getExpiry(name);\n            if (!expResponse?.expiry)\n                throw new Error(\"Couldn't get expiry for name, please provide one.\");\n            return BigNumber.from(expResponse.expiry.getTime() / 1000);\n        }\n        else {\n            return MAX_EXPIRY;\n        }\n    }\n};\n"],"names":["name","contracts","signer","getExpiry","owner","resolverAddress","contract","wrapperArgs","labels","split","length","Error","getPublicResolver","address","label","shift","labelhash","ethers","parentNodehash","namehash","join","getRegistry","registry","connect","populateTransaction","setSubnodeRecord","getNameWrapper","nameWrapper","makeExpiry","expiry","undefined","generatedFuses","fuses","generateFuseInput","fuseOptions","Object","keys","filter","opt","map","toUpperCase","reduce","prev","curr","or","toHexString","MAX_EXPIRY","BigNumber","pow","sub","Date","getTime","endsWith","expResponse"],"sourceRoot":""}