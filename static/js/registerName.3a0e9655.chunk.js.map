{"version":3,"file":"static/js/registerName.3a0e9655.chunk.js","mappings":"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","sources":["../node_modules/@ensdomains/ensjs/dist/esm/functions/registerName.js","../node_modules/@ensdomains/ensjs/dist/esm/utils/generateFuseInput.js","../node_modules/@ensdomains/ensjs/dist/esm/utils/recordHelpers.js","../node_modules/@ensdomains/ensjs/dist/esm/utils/registerHelpers.js"],"sourcesContent":["import { makeRegistrationData, } from '../utils/registerHelpers';\nexport default async function ({ contracts }, name, { resolverAddress, value, ...params }) {\n    const labels = name.split('.');\n    if (labels.length !== 2 || labels[1] !== 'eth')\n        throw new Error('Currently only .eth TLD registrations are supported');\n    const controller = await contracts.getEthRegistrarController();\n    const _resolver = await contracts.getPublicResolver(undefined, resolverAddress);\n    const generatedParams = makeRegistrationData({\n        name,\n        resolver: _resolver,\n        ...params,\n    });\n    return controller.populateTransaction.register(...generatedParams, {\n        value,\n    });\n}\n","import { ethers } from 'ethers';\nimport fuses from './fuses';\nexport default (fuseOptions) => {\n    const fuseKeys = Object.keys(fuseOptions)\n        .filter((opt) => fuseOptions[opt] === true)\n        .map((opt) => opt\n        .split(/(?=[A-Z])/)\n        .join('_')\n        .toUpperCase());\n    const bigNumberFuses = fuseKeys.reduce((prev, curr) => {\n        return prev.or(fuses[curr]);\n    }, ethers.BigNumber.from(0));\n    return bigNumberFuses.toHexString();\n};\n","import { formatsByCoinType, formatsByName } from '@ensdomains/address-encoder';\nimport { encodeContenthash } from './contentHash';\nexport const generateSetAddr = (namehash, coinType, address, resolver) => {\n    let coinTypeInstance;\n    if (!isNaN(parseInt(coinType))) {\n        coinTypeInstance = formatsByCoinType[parseInt(coinType)];\n    }\n    else {\n        coinTypeInstance = formatsByName[coinType.toUpperCase()];\n    }\n    const inputCoinType = coinTypeInstance.coinType;\n    const encodedAddress = coinTypeInstance.decoder(address);\n    return resolver?.interface.encodeFunctionData('setAddr(bytes32,uint256,bytes)', [namehash, inputCoinType, encodedAddress]);\n};\nexport function generateSingleRecordCall(namehash, resolver, type) {\n    if (type === 'contentHash') {\n        return (_r) => {\n            const record = _r;\n            let _contentHash = '';\n            if (record !== _contentHash) {\n                const encoded = encodeContenthash(record);\n                if (encoded.error)\n                    throw new Error(encoded.error);\n                _contentHash = encoded.encoded;\n            }\n            return resolver.interface.encodeFunctionData('setContenthash', [\n                namehash,\n                _contentHash,\n            ]);\n        };\n    }\n    else {\n        return (_r) => {\n            const record = _r;\n            if (type === 'text') {\n                return resolver.interface.encodeFunctionData('setText', [\n                    namehash,\n                    record.key,\n                    record.value,\n                ]);\n            }\n            else {\n                return generateSetAddr(namehash, record.key, record.value, resolver);\n            }\n        };\n    }\n}\nexport const generateRecordCallArray = (namehash, records, resolver) => {\n    const calls = [];\n    if (records.contentHash) {\n        const data = generateSingleRecordCall(namehash, resolver, 'contentHash')(records.contentHash);\n        data && calls.push(data);\n    }\n    if (records.texts && records.texts.length > 0) {\n        records.texts\n            .map(generateSingleRecordCall(namehash, resolver, 'text'))\n            .forEach((call) => calls.push(call));\n    }\n    if (records.coinTypes && records.coinTypes.length > 0) {\n        records.coinTypes\n            .map(generateSingleRecordCall(namehash, resolver, 'addr'))\n            .forEach((call) => calls.push(call));\n    }\n    return calls;\n};\n","import { utils } from 'ethers';\nimport generateFuseInput from './generateFuseInput';\nimport { labelhash } from './labels';\nimport { namehash } from './normalise';\nimport { generateRecordCallArray } from './recordHelpers';\nexport const randomSecret = () => {\n    const bytes = Buffer.allocUnsafe(32);\n    return '0x' + crypto.getRandomValues(bytes).toString('hex');\n};\nexport const makeCommitmentData = ({ name, owner, duration, resolver, records, reverseRecord, fuses, wrapperExpiry, secret, }) => {\n    const label = labelhash(name.split('.')[0]);\n    const hash = namehash(name);\n    const resolverAddress = resolver.address;\n    const fuseData = fuses ? generateFuseInput(fuses) : '0';\n    if (reverseRecord) {\n        if (!records) {\n            records = { coinTypes: [{ key: 'ETH', value: owner }] };\n        }\n        else if (!records.coinTypes?.find((c) => c.key === 'ETH')) {\n            if (!records.coinTypes)\n                records.coinTypes = [];\n            records.coinTypes.push({ key: 'ETH', value: owner });\n        }\n    }\n    const data = records ? generateRecordCallArray(hash, records, resolver) : [];\n    return [\n        label,\n        owner,\n        duration,\n        resolverAddress,\n        data,\n        secret,\n        !!reverseRecord,\n        fuseData,\n        wrapperExpiry || Math.floor(Date.now() / 1000) + duration,\n    ];\n};\nexport const makeRegistrationData = (params) => {\n    const commitmentData = makeCommitmentData(params);\n    commitmentData[0] = params.name.split('.')[0];\n    const secret = commitmentData.splice(5, 1)[0];\n    commitmentData.splice(3, 0, secret);\n    return commitmentData;\n};\nexport const makeCommitment = ({ secret = randomSecret(), ...inputParams }) => {\n    const generatedParams = makeCommitmentData({\n        ...inputParams,\n        secret,\n    });\n    const commitment = _makeCommitment(generatedParams);\n    return {\n        secret,\n        commitment,\n        wrapperExpiry: generatedParams[8],\n    };\n};\nexport const _makeCommitment = (params) => {\n    return utils.keccak256(utils.defaultAbiCoder.encode([\n        'bytes32',\n        'address',\n        'uint256',\n        'address',\n        'bytes[]',\n        'bytes32',\n        'bool',\n        'uint32',\n        'uint64',\n    ], params));\n};\n"],"names":["name","contracts","resolverAddress","value","params","labels","split","length","Error","getEthRegistrarController","controller","getPublicResolver","undefined","_resolver","generatedParams","makeRegistrationData","resolver","populateTransaction","register","fuseOptions","Object","keys","filter","opt","map","join","toUpperCase","reduce","prev","curr","or","fuses","ethers","toHexString","generateSingleRecordCall","namehash","type","_r","record","_contentHash","encoded","encodeContenthash","error","interface","encodeFunctionData","key","coinType","address","coinTypeInstance","inputCoinType","isNaN","parseInt","formatsByName","formatsByCoinType","encodedAddress","decoder","generateSetAddr","generateRecordCallArray","records","calls","contentHash","data","push","texts","forEach","call","coinTypes","makeCommitmentData","owner","duration","reverseRecord","wrapperExpiry","secret","label","labelhash","hash","fuseData","generateFuseInput","find","c","Math","floor","Date","now","commitmentData","splice","makeCommitment","bytes","Buffer","allocUnsafe","crypto","getRandomValues","toString","randomSecret","inputParams","commitment","_makeCommitment","utils"],"sourceRoot":""}