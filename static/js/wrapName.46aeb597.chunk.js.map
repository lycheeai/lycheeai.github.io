{"version":3,"file":"static/js/wrapName.46aeb597.chunk.js","mappings":"oPAIeA,EAAQ,EAARA,EAAAA,EAAAA,EAAAA,EAAAA,EAAAA,EAAAA,G,6EAAf,aAAsCC,EAAQC,EAAcC,EAAQC,EAAcC,EAAiBC,EAAQC,GAA3G,2FAAyBC,EAAzB,EAAyBA,UAAzB,gBAC8BA,QAD9B,IAC8BA,OAD9B,EAC8BA,EAAWC,iBADzC,cACUC,EADV,uBAEiCF,QAFjC,IAEiCA,OAFjC,EAEiCA,EAAWG,mBAF5C,cAEUC,EAFV,OAEgEC,QAAQP,GAC9DQ,EAAYC,EAAAA,UAA+B,CAAC,UAAW,CAACd,EAAO,KAC/De,EAAOD,EAAAA,EAAAA,OAAoC,CAAC,SAAU,UAAW,SAAU,SAAU,WAAY,CAACd,EAAO,GAAIC,EAAcE,EAAcD,EAAQE,IAJ3J,kBAKWO,EAAcK,oBAAoB,mDAAmDV,EAASG,EAAYH,QAASO,EAAWE,IALzI,6C,+BAOeE,EAAU,EAAVA,EAAAA,EAAAA,EAAAA,EAAAA,G,6EAAf,aAAwCC,EAAMjB,EAAcG,EAAiBE,EAASD,GAAtF,uFAA2BE,EAA3B,EAA2BA,UAA3B,gBAC+BA,QAD/B,IAC+BA,OAD/B,EAC+BA,EAAWC,iBAD1C,cACUC,EADV,OAC4DG,QAAQP,GADpE,gBAE2BE,QAF3B,IAE2BA,OAF3B,EAE2BA,EAAWY,cAFtC,cAEUC,EAFV,gBAG8BA,EAASC,iBAAiBf,EAASG,EAAYH,SAH7E,wCAKc,IAAIgB,MAAM,oEALxB,iCAOWb,EAAYO,oBAAoBO,MAAKC,EAAAA,EAAAA,GAAcN,GAAOjB,EAAcG,IAPnF,6C,sBASe,kBAAf,+B,8CAAe,aAAmDc,EAAnD,4GAAkBX,EAAlB,EAAkBA,UAAWF,EAA7B,EAA6BA,OAAQoB,EAArC,EAAqCA,UAAsBxB,EAA3D,EAA2DA,aAAcyB,EAAzE,EAAyEA,YAAaxB,EAAtF,EAAsFA,OAAQE,EAA9F,EAA8FA,gBAA9F,SACWC,EAAOsB,aADlB,cACLrB,EADK,uBAGkBC,QAHlB,IAGkBA,OAHlB,EAGkBA,EAAWqB,oBAH7B,UAGLC,EAHK,OAINzB,IACDA,EAAkByB,EAAevB,SAEf,KADhBN,EAASkB,EAAKY,MAAM,MACfC,QAA8B,QAAd/B,EAAO,GAPvB,6BAQQ0B,EARR,OASE,WATF,QAaE,WAbF,QAiBE,WAjBF,QAqBE,cArBF,gCAUCvB,GAAe6B,EAAAA,EAAAA,GAAkBN,GAVlC,oCAcCvB,EAAeuB,EAAYO,SAAS,IAdrC,oCAkBC9B,EAAeuB,EAlBhB,oCAsBCvB,EAAe,IAtBhB,mCA0BO,IAAImB,MAAJ,2CAA8CI,IA1BrD,0BA6BmBQ,EAAAA,EAAAA,GAAW,CAAET,UAAAA,GAAaP,EAAMhB,GA7BnD,eA6BDiC,EA7BC,yBA8BApC,EAAQ,CAAEQ,UAAAA,GAAaP,EAAQC,EAAckC,EAAahC,EAAcC,EAAiBC,EAAQC,IA9BjG,YAiCHoB,EAjCG,uBAkCG,IAAIJ,MAAM,gEAlCb,YAmCHpB,EAnCG,uBAoCG,IAAIoB,MAAM,iEApCb,iCAqCAL,EAAU,CAAEV,UAAAA,GAAaW,EAAMjB,EAAcG,EAAiBE,EAASD,IArCvE,6C,sEClBf,aAAgBqB,GAUZ,OATiBU,OAAOC,KAAKX,GACxBY,QAAO,SAACC,GAAD,OAA8B,IAArBb,EAAYa,EAArB,IACPC,KAAI,SAACD,GAAD,OAASA,EACbT,MAAM,aACNW,KAAK,KACLC,aAHI,IAIuBC,QAAO,SAACC,EAAMC,GAC1C,OAAOD,EAAKE,GAAGC,EAAAA,GAAMF,GACxB,GAAE/B,EAAAA,GAAAA,KAAsB,IACHkC,aAV1B,C,uECDaxB,EAAgB,SAACN,GAAD,kBAAe+B,EAAAA,KAAAA,OAAmB/B,GAAMe,SAAS,OAAjD,C,4FCAhBiB,EAAaC,EAAAA,GAAAA,KAAe,GAAGC,IAAI,IAAIC,IAAI,GAC3CnB,EAAU,yCAAG,aAAsBhB,EAAMhB,GAA5B,iFAASuB,EAAT,EAASA,WAC3BvB,EADkB,sBAEdA,aAAkBoD,MAFJ,yCAGPH,EAAAA,GAAAA,KAAejD,EAAOqD,UAAY,MAH3B,YAKTrD,aAAkBiD,EAAAA,IALT,0CAMPjD,GANO,iCASPiD,EAAAA,GAAAA,KAAejD,IATR,oCAadgB,EAAKsC,SAAS,QAbA,kCAcY/B,EAAUP,GAdtB,mBAcRuC,EAdQ,kBAeTA,GAAAA,EAAavD,OAfJ,uBAgBJ,IAAIoB,MAAM,qDAhBN,iCAiBP6B,EAAAA,GAAAA,KAAeM,EAAYvD,OAAOqD,UAAY,MAjBvC,iCAoBPL,GApBO,4CAAH,yD","sources":["../node_modules/@ensdomains/ensjs/dist/esm/functions/wrapName.js","../node_modules/@ensdomains/ensjs/dist/esm/utils/generateFuseInput.js","../node_modules/@ensdomains/ensjs/dist/esm/utils/hexEncodedName.js","../node_modules/@ensdomains/ensjs/dist/esm/utils/wrapperExpiry.js"],"sourcesContent":["import { ethers } from 'ethers';\nimport generateFuseInput from '../utils/generateFuseInput';\nimport { hexEncodeName } from '../utils/hexEncodedName';\nimport { makeExpiry } from '../utils/wrapperExpiry';\nasync function wrapETH({ contracts }, labels, wrappedOwner, expiry, decodedFuses, resolverAddress, signer, address) {\n    const nameWrapper = await contracts?.getNameWrapper();\n    const baseRegistrar = (await contracts?.getBaseRegistrar()).connect(signer);\n    const labelhash = ethers.utils.solidityKeccak256(['string'], [labels[0]]);\n    const data = ethers.utils.defaultAbiCoder.encode(['string', 'address', 'uint32', 'uint64', 'address'], [labels[0], wrappedOwner, decodedFuses, expiry, resolverAddress]);\n    return baseRegistrar.populateTransaction['safeTransferFrom(address,address,uint256,bytes)'](address, nameWrapper.address, labelhash, data);\n}\nasync function wrapOther({ contracts }, name, wrappedOwner, resolverAddress, address, signer) {\n    const nameWrapper = (await contracts?.getNameWrapper()).connect(signer);\n    const registry = await contracts?.getRegistry();\n    const hasApproval = await registry.isApprovedForAll(address, nameWrapper.address);\n    if (!hasApproval) {\n        throw new Error('NameWrapper must have approval to wrap a name from this address.');\n    }\n    return nameWrapper.populateTransaction.wrap(hexEncodeName(name), wrappedOwner, resolverAddress);\n}\nexport default async function ({ contracts, signer, getExpiry, }, name, { wrappedOwner, fuseOptions, expiry, resolverAddress, }) {\n    const address = await signer.getAddress();\n    let decodedFuses;\n    const publicResolver = await contracts?.getPublicResolver();\n    if (!resolverAddress)\n        resolverAddress = publicResolver.address;\n    const labels = name.split('.');\n    if (labels.length === 2 && labels[1] === 'eth') {\n        switch (typeof fuseOptions) {\n            case 'object': {\n                decodedFuses = generateFuseInput(fuseOptions);\n                break;\n            }\n            case 'number': {\n                decodedFuses = fuseOptions.toString(16);\n                break;\n            }\n            case 'string': {\n                decodedFuses = fuseOptions;\n                break;\n            }\n            case 'undefined': {\n                decodedFuses = '0';\n                break;\n            }\n            default: {\n                throw new Error(`Invalid fuseOptions type: ${typeof fuseOptions}`);\n            }\n        }\n        const expiryToUse = await makeExpiry({ getExpiry }, name, expiry);\n        return wrapETH({ contracts }, labels, wrappedOwner, expiryToUse, decodedFuses, resolverAddress, signer, address);\n    }\n    else {\n        if (fuseOptions)\n            throw new Error('Fuses can not be initially set when wrapping a non .eth name');\n        if (expiry)\n            throw new Error('Expiry can not be initially set when wrapping a non .eth name');\n        return wrapOther({ contracts }, name, wrappedOwner, resolverAddress, address, signer);\n    }\n}\n","import { ethers } from 'ethers';\nimport fuses from './fuses';\nexport default (fuseOptions) => {\n    const fuseKeys = Object.keys(fuseOptions)\n        .filter((opt) => fuseOptions[opt] === true)\n        .map((opt) => opt\n        .split(/(?=[A-Z])/)\n        .join('_')\n        .toUpperCase());\n    const bigNumberFuses = fuseKeys.reduce((prev, curr) => {\n        return prev.or(fuses[curr]);\n    }, ethers.BigNumber.from(0));\n    return bigNumberFuses.toHexString();\n};\n","import packet from 'dns-packet';\nexport const hexEncodeName = (name) => `0x${packet.name.encode(name).toString('hex')}`;\n","import { BigNumber } from 'ethers';\nexport const MAX_EXPIRY = BigNumber.from(2).pow(64).sub(1);\nexport const makeExpiry = async ({ getExpiry }, name, expiry) => {\n    if (expiry) {\n        if (expiry instanceof Date) {\n            return BigNumber.from(expiry.getTime() / 1000);\n        }\n        else if (expiry instanceof BigNumber) {\n            return expiry;\n        }\n        else {\n            return BigNumber.from(expiry);\n        }\n    }\n    else {\n        if (name.endsWith('.eth')) {\n            const expResponse = await getExpiry(name);\n            if (!expResponse?.expiry)\n                throw new Error(\"Couldn't get expiry for name, please provide one.\");\n            return BigNumber.from(expResponse.expiry.getTime() / 1000);\n        }\n        else {\n            return MAX_EXPIRY;\n        }\n    }\n};\n"],"names":["wrapETH","labels","wrappedOwner","expiry","decodedFuses","resolverAddress","signer","address","contracts","getNameWrapper","nameWrapper","getBaseRegistrar","baseRegistrar","connect","labelhash","ethers","data","populateTransaction","wrapOther","name","getRegistry","registry","isApprovedForAll","Error","wrap","hexEncodeName","getExpiry","fuseOptions","getAddress","getPublicResolver","publicResolver","split","length","generateFuseInput","toString","makeExpiry","expiryToUse","Object","keys","filter","opt","map","join","toUpperCase","reduce","prev","curr","or","fuses","toHexString","packet","MAX_EXPIRY","BigNumber","pow","sub","Date","getTime","endsWith","expResponse"],"sourceRoot":""}