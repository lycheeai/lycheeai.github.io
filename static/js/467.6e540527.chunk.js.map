{"version":3,"file":"static/js/467.6e540527.chunk.js","mappings":"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","sources":["../node_modules/@ensdomains/ensjs/dist/esm/functions/getSpecificRecord.js"],"sourcesContent":["import { formatsByCoinType, formatsByName } from '@ensdomains/address-encoder';\nimport { ethers } from 'ethers';\nimport { decodeContenthash } from '../utils/contentHash';\nimport { namehash } from '../utils/normalise';\nexport const _getContentHash = {\n    raw: async ({ contracts }, name) => {\n        const publicResolver = await contracts?.getPublicResolver();\n        return {\n            to: '0x0000000000000000000000000000000000000000',\n            data: publicResolver.interface.encodeFunctionData('contenthash', [\n                namehash(name),\n            ]),\n        };\n    },\n    decode: async ({ contracts }, data) => {\n        let response;\n        const publicResolver = await contracts?.getPublicResolver();\n        try {\n            ;\n            [response] = publicResolver.interface.decodeFunctionResult('contenthash', data);\n        }\n        catch {\n            return;\n        }\n        if (!response) {\n            return;\n        }\n        const decodedContent = decodeContenthash(response);\n        if (!decodedContent ||\n            (ethers.utils.isBytesLike(decodedContent.decoded) &&\n                ethers.utils.hexStripZeros(decodedContent.decoded) === '0x') ||\n            Object.keys(decodedContent).length === 0) {\n            return;\n        }\n        return decodedContent;\n    },\n};\nexport const getContentHash = {\n    raw: async ({ contracts, universalWrapper }, name) => {\n        const prData = await _getContentHash.raw({ contracts }, name);\n        return await universalWrapper.raw(name, prData.data);\n    },\n    decode: async ({ contracts, universalWrapper }, data) => {\n        const urData = await universalWrapper.decode(data);\n        if (!urData)\n            return;\n        return await _getContentHash.decode({ contracts }, urData.data);\n    },\n};\nexport const _getText = {\n    raw: async ({ contracts }, name, key) => {\n        const publicResolver = await contracts?.getPublicResolver();\n        return {\n            to: '0x0000000000000000000000000000000000000000',\n            data: publicResolver.interface.encodeFunctionData('text', [\n                namehash(name),\n                key,\n            ]),\n        };\n    },\n    decode: async ({ contracts }, data) => {\n        const publicResolver = await contracts?.getPublicResolver();\n        const [response] = publicResolver.interface.decodeFunctionResult('text', data);\n        if (!response) {\n            return;\n        }\n        return response;\n    },\n};\nexport const getText = {\n    raw: async ({ contracts, universalWrapper }, name, key) => {\n        const prData = await _getText.raw({ contracts }, name, key);\n        return await universalWrapper.raw(name, prData.data);\n    },\n    decode: async ({ contracts, universalWrapper }, data) => {\n        const urData = await universalWrapper.decode(data);\n        if (!urData)\n            return;\n        return await _getText.decode({ contracts }, urData.data);\n    },\n};\nexport const _getAddr = {\n    raw: async ({ contracts }, name, coinType, bypassFormat) => {\n        if (!coinType) {\n            coinType = 60;\n        }\n        const publicResolver = await contracts?.getPublicResolver();\n        if (coinType === 60 || coinType === '60') {\n            return {\n                to: '0x0000000000000000000000000000000000000000',\n                data: publicResolver.interface.encodeFunctionData('addr(bytes32)', [\n                    namehash(name),\n                ]),\n            };\n        }\n        if (bypassFormat) {\n            return {\n                to: '0x0000000000000000000000000000000000000000',\n                data: publicResolver.interface.encodeFunctionData('addr(bytes32,uint256)', [namehash(name), coinType]),\n            };\n        }\n        const formatter = typeof coinType === 'string' && isNaN(parseInt(coinType))\n            ? formatsByName[coinType]\n            : formatsByCoinType[typeof coinType === 'number' ? coinType : parseInt(coinType)];\n        if (!formatter) {\n            throw new Error(`No formatter found for coin: ${coinType}`);\n        }\n        return {\n            to: '0x0000000000000000000000000000000000000000',\n            data: publicResolver.interface.encodeFunctionData('addr(bytes32,uint256)', [namehash(name), formatter.coinType]),\n        };\n    },\n    decode: async ({ contracts }, data, _name, coinType) => {\n        let returnCoinType = true;\n        if (!coinType) {\n            coinType = 60;\n            returnCoinType = false;\n        }\n        const publicResolver = await contracts?.getPublicResolver();\n        const formatter = typeof coinType === 'string' && isNaN(parseInt(coinType))\n            ? formatsByName[coinType]\n            : formatsByCoinType[typeof coinType === 'number' ? coinType : parseInt(coinType)];\n        let response;\n        if (coinType === 60 || coinType === '60') {\n            ;\n            [response] = publicResolver.interface.decodeFunctionResult('addr(bytes32)', data);\n        }\n        else {\n            ;\n            [response] = publicResolver.interface.decodeFunctionResult('addr(bytes32,uint256)', data);\n        }\n        if (!response)\n            return;\n        if (ethers.utils.hexStripZeros(response) === '0x') {\n            return;\n        }\n        const decodedAddr = formatter.encoder(Buffer.from(response.slice(2), 'hex'));\n        if (!decodedAddr) {\n            return;\n        }\n        if (!returnCoinType) {\n            return decodedAddr;\n        }\n        return { coin: formatter.name, addr: decodedAddr };\n    },\n};\nexport const getAddr = {\n    raw: async ({ contracts, universalWrapper }, name, coinType) => {\n        const prData = await _getAddr.raw({ contracts }, name, coinType);\n        return await universalWrapper.raw(name, prData.data);\n    },\n    decode: async ({ contracts, universalWrapper }, data, _name, coinType) => {\n        const urData = await universalWrapper.decode(data);\n        if (!urData)\n            return;\n        return await _getAddr.decode({ contracts }, urData.data, _name, coinType);\n    },\n};\n// export async function getAddr(\n//   { contracts }: ENSArgs<'contracts'>,\n//   name: string,\n//   coinType?: string | number,\n// ) {\n//   if (!coinType) {\n//     coinType = 60\n//   }\n//   const universalResolver = await contracts?.getUniversalResolver()\n//   const publicResolver = await contracts?.getPublicResolver()\n//   const formatter =\n//     typeof coinType === 'string'\n//       ? formatsByName[coinType]\n//       : formatsByCoinType[coinType]\n//   if (!formatter) {\n//     throw new Error(`Coin type ${coinType} is not supported`)\n//   }\n//   const data = publicResolver?.interface.encodeFunctionData(\n//     'addr(bytes32,uint256)',\n//     [ethers.utils.namehash(name), formatter.coinType],\n//   )\n//   const result = await universalResolver?.resolve(hexEncodeName(name), data)\n//   const [encodedAddr] = ethers.utils.defaultAbiCoder.decode(\n//     ['bytes'],\n//     result['0'],\n//   )\n//   if (ethers.utils.hexStripZeros(encodedAddr) === '0x') {\n//     return\n//   }\n//   const decodedAddr = formatter.encoder(\n//     Buffer.from(encodedAddr.slice(2), 'hex'),\n//   )\n//   if (!decodedAddr) {\n//     return\n//   }\n//   return decodedAddr\n// }\n// export const getContentHash = {\n//   raw: async ({ contracts }: ENSArgs<'contracts'>, name: string) => {\n//     const universalResolver = await contracts?.getUniversalResolver()!\n//     const publicResolver = await contracts?.getPublicResolver()!\n//     const prData = publicResolver.interface.encodeFunctionData(\n//       'contenthash(bytes32)',\n//       [ethers.utils.namehash(name)],\n//     )\n//     const urData = universalResolver.interface.encodeFunctionData(\n//       'resolve(bytes,bytes)',\n//       [hexEncodeName(name), prData],\n//     )\n//     return {\n//       to: universalResolver.address,\n//       data: urData,\n//     }\n//   },\n//   decode: async ({ contracts }: ENSArgs<'contracts'>, data: string) => {\n//     const universalResolver = await contracts?.getUniversalResolver()!\n//     const publicResolver = await contracts?.getPublicResolver()!\n//     const response = universalResolver.interface.decodeFunctionResult(\n//       'resolve(bytes,bytes)',\n//       data,\n//     )\n//     if (!response || !response[1]) {\n//       return\n//     }\n//     const [encodedContentHash] = publicResolver.interface.decodeFunctionResult(\n//       'contenthash(bytes32)',\n//       response[0],\n//     )\n//     if (ethers.utils.hexStripZeros(encodedContentHash) === '0x') {\n//       return\n//     }\n//     return decodeContenthash(encodedContentHash)\n//   },\n// }\n// const getText = {\n//   raw: async (\n//     { contracts }: ENSArgs<'contracts'>,\n//     name: string,\n//     key: string,\n//   ) => {\n//     const universalResolver = await contracts?.getUniversalResolver()!\n//     const publicResolver = await contracts?.getPublicResolver()!\n//     const data = publicResolver.interface.encodeFunctionData(\n//       'text(bytes32,string)',\n//       [ethers.utils.namehash(name), key],\n//     )\n//     return {\n//       to: universalResolver.address,\n//       data: universalResolver.interface.encodeFunctionData(\n//         'resolve(bytes,bytes)',\n//         [hexEncodeName(name), data],\n//       ),\n//     }\n//   },\n//   decode: async ({ contracts }: ENSArgs<'contracts'>, data: string) => {\n//     const universalResolver = await contracts?.getUniversalResolver()!\n//     const publicResolver = await contracts?.getPublicResolver()!\n//     const response = universalResolver.interface.decodeFunctionResult(\n//       'resolve(bytes,bytes)',\n//       data,\n//     )\n//     if (!response || !response[1]) {\n//       return\n//     }\n//     const [decodedText] = publicResolver.interface.decodeFunctionResult(\n//       'text(bytes32,string)',\n//       response[0],\n//     )\n//     if (decodedText === '') {\n//       return\n//     }\n//     return decodedText\n//   },\n// }\n"],"names":["_getContentHash","raw","name","contracts","getPublicResolver","publicResolver","to","data","interface","encodeFunctionData","namehash","decode","decodeFunctionResult","response","decodedContent","decodeContenthash","ethers","decoded","Object","keys","length","getContentHash","universalWrapper","prData","urData","_getText","key","getText","_getAddr","coinType","bypassFormat","formatter","isNaN","parseInt","formatsByName","formatsByCoinType","Error","_name","returnCoinType","decodedAddr","encoder","Buffer","from","slice","coin","addr","getAddr"],"sourceRoot":""}