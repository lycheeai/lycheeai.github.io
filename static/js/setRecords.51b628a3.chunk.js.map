{"version":3,"file":"static/js/setRecords.51b628a3.chunk.js","mappings":"uNAEe,kBAAf,+B,8CAAe,aAA+DA,EAA/D,sGAAkBC,EAAlB,EAAkBA,UAAWC,EAA7B,EAA6BA,SAAUC,EAAvC,EAAuCA,YAAaC,EAApD,EAAoDA,OAAmBC,EAAvE,EAAuEA,QAASC,EAAhF,EAAgFA,gBACtFN,EAAKO,SAAS,KADR,sBAED,IAAIC,MAAM,4BAFT,WAKPF,EALO,gBAMPG,EAAgBH,EANT,wCASeH,EAAYH,GAT3B,QASPS,EATO,kBAWNA,EAXM,uBAYD,IAAID,MAAM,uCAZT,gCAcaP,QAdb,IAcaA,OAdb,EAcaA,EAAWS,kBAAkBR,EAAUO,GAdpD,2JAcM,EAA+DE,QAAQP,GAd7E,eAcLQ,EAdK,KAeLC,GAAOC,EAAAA,EAAAA,GAASd,GAChBe,GAAQC,EAAAA,EAAAA,IAAwBH,EAAMR,EAASO,GAhB1C,kBAiBJA,EAASK,oBAAoBC,UAAUH,IAjBnC,6C,8ICYR,SAASI,EAAyBL,EAAUF,EAAUQ,GACzD,MAAa,gBAATA,EACO,SAACC,GACJ,IAAMC,EAASD,EACXE,EAAe,GACnB,GAAID,IAAWC,EAAc,CACzB,IAAMC,GAAUC,EAAAA,EAAAA,IAAkBH,GAClC,GAAIE,EAAQE,MACR,MAAM,IAAIlB,MAAMgB,EAAQE,OAC5BH,EAAeC,EAAQA,OAC1B,CACD,OAAOZ,EAASe,UAAUC,mBAAmB,iBAAkB,CAC3Dd,EACAS,GAEP,EAGM,SAACF,GACJ,IAAMC,EAASD,EACf,MAAa,SAATD,EACOR,EAASe,UAAUC,mBAAmB,UAAW,CACpDd,EACAQ,EAAOO,IACPP,EAAOQ,QApCI,SAAChB,EAAUiB,EAAUC,EAASpB,GACzD,IAAIqB,EAOEC,GAFFD,EAJCE,MAAMC,SAASL,IAIGM,EAAAA,GAAcN,EAASO,eAHvBC,EAAAA,GAAkBH,SAASL,KAKXA,SACjCS,EAAiBP,EAAiBQ,QAAQT,GAChD,cAAOpB,QAAP,IAAOA,OAAP,EAAOA,EAAUe,UAAUC,mBAAmB,iCAAkC,CAACd,EAAUoB,EAAeM,GAC7G,CA6BsBE,CAAgB5B,EAAUQ,EAAOO,IAAKP,EAAOQ,MAAOlB,EAElE,CAER,CACM,IAAMI,EAA0B,SAACF,EAAUT,EAASO,GACvD,IAAMG,EAAQ,GACd,GAAIV,EAAQsC,YAAa,CACrB,IAAMC,EAAOzB,EAAyBL,EAAUF,EAAU,cAA7CO,CAA4Dd,EAAQsC,aACjFC,GAAQ7B,EAAM8B,KAAKD,EACtB,CAWD,OAVIvC,EAAQyC,OAASzC,EAAQyC,MAAMC,OAAS,GACxC1C,EAAQyC,MACHE,IAAI7B,EAAyBL,EAAUF,EAAU,SACjDqC,SAAQ,SAACC,GAAD,OAAUnC,EAAM8B,KAAKK,EAArB,IAEb7C,EAAQ8C,WAAa9C,EAAQ8C,UAAUJ,OAAS,GAChD1C,EAAQ8C,UACHH,IAAI7B,EAAyBL,EAAUF,EAAU,SACjDqC,SAAQ,SAACC,GAAD,OAAUnC,EAAM8B,KAAKK,EAArB,IAEVnC,CACV,C","sources":["../node_modules/@ensdomains/ensjs/dist/esm/functions/setRecords.js","../node_modules/@ensdomains/ensjs/dist/esm/utils/recordHelpers.js"],"sourcesContent":["import { namehash } from '../utils/normalise';\nimport { generateRecordCallArray } from '../utils/recordHelpers';\nexport default async function ({ contracts, provider, getResolver, signer, }, name, { records, resolverAddress, }) {\n    if (!name.includes('.')) {\n        throw new Error('Input is not an ENS name');\n    }\n    let resolverToUse;\n    if (resolverAddress) {\n        resolverToUse = resolverAddress;\n    }\n    else {\n        resolverToUse = await getResolver(name);\n    }\n    if (!resolverToUse) {\n        throw new Error('No resolver found for input address');\n    }\n    const resolver = (await contracts?.getPublicResolver(provider, resolverToUse))?.connect(signer);\n    const hash = namehash(name);\n    const calls = generateRecordCallArray(hash, records, resolver);\n    return resolver.populateTransaction.multicall(calls);\n}\n","import { formatsByCoinType, formatsByName } from '@ensdomains/address-encoder';\nimport { encodeContenthash } from './contentHash';\nexport const generateSetAddr = (namehash, coinType, address, resolver) => {\n    let coinTypeInstance;\n    if (!isNaN(parseInt(coinType))) {\n        coinTypeInstance = formatsByCoinType[parseInt(coinType)];\n    }\n    else {\n        coinTypeInstance = formatsByName[coinType.toUpperCase()];\n    }\n    const inputCoinType = coinTypeInstance.coinType;\n    const encodedAddress = coinTypeInstance.decoder(address);\n    return resolver?.interface.encodeFunctionData('setAddr(bytes32,uint256,bytes)', [namehash, inputCoinType, encodedAddress]);\n};\nexport function generateSingleRecordCall(namehash, resolver, type) {\n    if (type === 'contentHash') {\n        return (_r) => {\n            const record = _r;\n            let _contentHash = '';\n            if (record !== _contentHash) {\n                const encoded = encodeContenthash(record);\n                if (encoded.error)\n                    throw new Error(encoded.error);\n                _contentHash = encoded.encoded;\n            }\n            return resolver.interface.encodeFunctionData('setContenthash', [\n                namehash,\n                _contentHash,\n            ]);\n        };\n    }\n    else {\n        return (_r) => {\n            const record = _r;\n            if (type === 'text') {\n                return resolver.interface.encodeFunctionData('setText', [\n                    namehash,\n                    record.key,\n                    record.value,\n                ]);\n            }\n            else {\n                return generateSetAddr(namehash, record.key, record.value, resolver);\n            }\n        };\n    }\n}\nexport const generateRecordCallArray = (namehash, records, resolver) => {\n    const calls = [];\n    if (records.contentHash) {\n        const data = generateSingleRecordCall(namehash, resolver, 'contentHash')(records.contentHash);\n        data && calls.push(data);\n    }\n    if (records.texts && records.texts.length > 0) {\n        records.texts\n            .map(generateSingleRecordCall(namehash, resolver, 'text'))\n            .forEach((call) => calls.push(call));\n    }\n    if (records.coinTypes && records.coinTypes.length > 0) {\n        records.coinTypes\n            .map(generateSingleRecordCall(namehash, resolver, 'addr'))\n            .forEach((call) => calls.push(call));\n    }\n    return calls;\n};\n"],"names":["name","contracts","provider","getResolver","signer","records","resolverAddress","includes","Error","resolverToUse","getPublicResolver","connect","resolver","hash","namehash","calls","generateRecordCallArray","populateTransaction","multicall","generateSingleRecordCall","type","_r","record","_contentHash","encoded","encodeContenthash","error","interface","encodeFunctionData","key","value","coinType","address","coinTypeInstance","inputCoinType","isNaN","parseInt","formatsByName","toUpperCase","formatsByCoinType","encodedAddress","decoder","generateSetAddr","contentHash","data","push","texts","length","map","forEach","call","coinTypes"],"sourceRoot":""}