{"version":3,"file":"static/js/setRecord.f1a50425.chunk.js","mappings":"gNAEe,kBAAf,+B,8CAAe,aAA+DA,EAA/D,wGAAkBC,EAAlB,EAAkBA,UAAWC,EAA7B,EAA6BA,SAAUC,EAAvC,EAAuCA,YAAaC,EAApD,EAAoDA,OAAmBC,EAAvE,EAAuEA,OAAQC,EAA/E,EAA+EA,KAAMC,EAArF,EAAqFA,gBAC3FP,EAAKQ,SAAS,KADR,sBAED,IAAIC,MAAM,4BAFT,WAKPF,EALO,gBAMPG,EAAgBH,EANT,wCASeJ,EAAYH,GAT3B,QASPU,EATO,kBAWNA,EAXM,uBAYD,IAAID,MAAM,uCAZT,gCAcaR,QAdb,IAcaA,OAdb,EAcaA,EAAWU,kBAAkBT,EAAUQ,GAdpD,2JAcM,EAA+DE,QAAQR,GAd7E,eAcLS,EAdK,KAeLC,GAAOC,EAAAA,EAAAA,GAASf,GAChBgB,GAAOC,EAAAA,EAAAA,IAAyBH,EAAMD,EAAUP,EAAzCW,CAA+CZ,GAhBjD,kBAiBJ,CACHa,GAAIL,EAASM,QACbC,KAAMJ,IAnBC,6C,0ICYR,SAASC,EAAyBF,EAAUF,EAAUP,GACzD,MAAa,gBAATA,EACO,SAACe,GACJ,IAAMhB,EAASgB,EACXC,EAAe,GACnB,GAAIjB,IAAWiB,EAAc,CACzB,IAAMC,GAAUC,EAAAA,EAAAA,IAAkBnB,GAClC,GAAIkB,EAAQE,MACR,MAAM,IAAIhB,MAAMc,EAAQE,OAC5BH,EAAeC,EAAQA,OAC1B,CACD,OAAOV,EAASa,UAAUC,mBAAmB,iBAAkB,CAC3DZ,EACAO,GAEP,EAGM,SAACD,GACJ,IAAMhB,EAASgB,EACf,MAAa,SAATf,EACOO,EAASa,UAAUC,mBAAmB,UAAW,CACpDZ,EACAV,EAAOuB,IACPvB,EAAOwB,QApCI,SAACd,EAAUe,EAAUX,EAASN,GACzD,IAAIkB,EAOEC,GAFFD,EAJCE,MAAMC,SAASJ,IAIGK,EAAAA,GAAcL,EAASM,eAHvBC,EAAAA,GAAkBH,SAASJ,KAKXA,SACjCQ,EAAiBP,EAAiBQ,QAAQpB,GAChD,cAAON,QAAP,IAAOA,OAAP,EAAOA,EAAUa,UAAUC,mBAAmB,iCAAkC,CAACZ,EAAUiB,EAAeM,GAC7G,CA6BsBE,CAAgBzB,EAAUV,EAAOuB,IAAKvB,EAAOwB,MAAOhB,EAElE,CAER,CACM,IAAM4B,EAA0B,SAAC1B,EAAU2B,EAAS7B,GACvD,IAAM8B,EAAQ,GACd,GAAID,EAAQE,YAAa,CACrB,IAAMxB,EAAOH,EAAyBF,EAAUF,EAAU,cAA7CI,CAA4DyB,EAAQE,aACjFxB,GAAQuB,EAAME,KAAKzB,EACtB,CAWD,OAVIsB,EAAQI,OAASJ,EAAQI,MAAMC,OAAS,GACxCL,EAAQI,MACHE,IAAI/B,EAAyBF,EAAUF,EAAU,SACjDoC,SAAQ,SAACjC,GAAD,OAAU2B,EAAME,KAAK7B,EAArB,IAEb0B,EAAQQ,WAAaR,EAAQQ,UAAUH,OAAS,GAChDL,EAAQQ,UACHF,IAAI/B,EAAyBF,EAAUF,EAAU,SACjDoC,SAAQ,SAACjC,GAAD,OAAU2B,EAAME,KAAK7B,EAArB,IAEV2B,CACV,C","sources":["../node_modules/@ensdomains/ensjs/dist/esm/functions/setRecord.js","../node_modules/@ensdomains/ensjs/dist/esm/utils/recordHelpers.js"],"sourcesContent":["import { namehash } from '../utils/normalise';\nimport { generateSingleRecordCall, } from '../utils/recordHelpers';\nexport default async function ({ contracts, provider, getResolver, signer, }, name, { record, type, resolverAddress, }) {\n    if (!name.includes('.')) {\n        throw new Error('Input is not an ENS name');\n    }\n    let resolverToUse;\n    if (resolverAddress) {\n        resolverToUse = resolverAddress;\n    }\n    else {\n        resolverToUse = await getResolver(name);\n    }\n    if (!resolverToUse) {\n        throw new Error('No resolver found for input address');\n    }\n    const resolver = (await contracts?.getPublicResolver(provider, resolverToUse))?.connect(signer);\n    const hash = namehash(name);\n    const call = generateSingleRecordCall(hash, resolver, type)(record);\n    return {\n        to: resolver.address,\n        data: call,\n    };\n}\n","import { formatsByCoinType, formatsByName } from '@ensdomains/address-encoder';\nimport { encodeContenthash } from './contentHash';\nexport const generateSetAddr = (namehash, coinType, address, resolver) => {\n    let coinTypeInstance;\n    if (!isNaN(parseInt(coinType))) {\n        coinTypeInstance = formatsByCoinType[parseInt(coinType)];\n    }\n    else {\n        coinTypeInstance = formatsByName[coinType.toUpperCase()];\n    }\n    const inputCoinType = coinTypeInstance.coinType;\n    const encodedAddress = coinTypeInstance.decoder(address);\n    return resolver?.interface.encodeFunctionData('setAddr(bytes32,uint256,bytes)', [namehash, inputCoinType, encodedAddress]);\n};\nexport function generateSingleRecordCall(namehash, resolver, type) {\n    if (type === 'contentHash') {\n        return (_r) => {\n            const record = _r;\n            let _contentHash = '';\n            if (record !== _contentHash) {\n                const encoded = encodeContenthash(record);\n                if (encoded.error)\n                    throw new Error(encoded.error);\n                _contentHash = encoded.encoded;\n            }\n            return resolver.interface.encodeFunctionData('setContenthash', [\n                namehash,\n                _contentHash,\n            ]);\n        };\n    }\n    else {\n        return (_r) => {\n            const record = _r;\n            if (type === 'text') {\n                return resolver.interface.encodeFunctionData('setText', [\n                    namehash,\n                    record.key,\n                    record.value,\n                ]);\n            }\n            else {\n                return generateSetAddr(namehash, record.key, record.value, resolver);\n            }\n        };\n    }\n}\nexport const generateRecordCallArray = (namehash, records, resolver) => {\n    const calls = [];\n    if (records.contentHash) {\n        const data = generateSingleRecordCall(namehash, resolver, 'contentHash')(records.contentHash);\n        data && calls.push(data);\n    }\n    if (records.texts && records.texts.length > 0) {\n        records.texts\n            .map(generateSingleRecordCall(namehash, resolver, 'text'))\n            .forEach((call) => calls.push(call));\n    }\n    if (records.coinTypes && records.coinTypes.length > 0) {\n        records.coinTypes\n            .map(generateSingleRecordCall(namehash, resolver, 'addr'))\n            .forEach((call) => calls.push(call));\n    }\n    return calls;\n};\n"],"names":["name","contracts","provider","getResolver","signer","record","type","resolverAddress","includes","Error","resolverToUse","getPublicResolver","connect","resolver","hash","namehash","call","generateSingleRecordCall","to","address","data","_r","_contentHash","encoded","encodeContenthash","error","interface","encodeFunctionData","key","value","coinType","coinTypeInstance","inputCoinType","isNaN","parseInt","formatsByName","toUpperCase","formatsByCoinType","encodedAddress","decoder","generateSetAddr","generateRecordCallArray","records","calls","contentHash","push","texts","length","map","forEach","coinTypes"],"sourceRoot":""}