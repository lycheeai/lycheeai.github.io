{"version":3,"file":"static/js/getOwner.3295f49a.chunk.js","mappings":"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","sources":["../node_modules/@ensdomains/ensjs/dist/esm/functions/getOwner.js"],"sourcesContent":["import { ethers } from 'ethers';\nimport { labelhash } from '../utils/labels';\nimport { namehash as makeNamehash } from '../utils/normalise';\nconst singleContractOwnerRaw = async ({ contracts }, contract, namehash, labels) => {\n    switch (contract) {\n        case 'nameWrapper': {\n            const nameWrapper = await contracts?.getNameWrapper();\n            return {\n                to: nameWrapper.address,\n                data: nameWrapper.interface.encodeFunctionData('ownerOf', [namehash]),\n            };\n        }\n        case 'registry': {\n            const registry = await contracts?.getRegistry();\n            return {\n                to: registry.address,\n                data: registry.interface.encodeFunctionData('owner', [namehash]),\n            };\n        }\n        case 'registrar': {\n            const registrar = await contracts?.getBaseRegistrar();\n            return {\n                to: registrar.address,\n                data: registrar.interface.encodeFunctionData('ownerOf', [\n                    labelhash(labels[0]),\n                ]),\n            };\n        }\n    }\n};\nconst raw = async ({ contracts, multicallWrapper }, name, contract) => {\n    const namehash = makeNamehash(name);\n    const labels = name.split('.');\n    if (contract || labels.length === 1) {\n        return await singleContractOwnerRaw({ contracts }, contract || 'registry', namehash, labels);\n    }\n    const registryData = await singleContractOwnerRaw({ contracts }, 'registry', namehash, labels);\n    const nameWrapperData = await singleContractOwnerRaw({ contracts }, 'nameWrapper', namehash, labels);\n    const registrarData = await singleContractOwnerRaw({ contracts }, 'registrar', namehash, labels);\n    const data = [registryData, nameWrapperData];\n    if (labels.length == 2 && labels[1] === 'eth') {\n        data.push(registrarData);\n    }\n    return multicallWrapper.raw(data);\n};\nconst singleContractOwnerDecode = (data) => ethers.utils.defaultAbiCoder.decode(['address'], data)[0];\nconst decode = async ({ contracts, multicallWrapper }, data, name, contract) => {\n    if (data === null)\n        return;\n    const labels = name.split('.');\n    if (contract || labels.length === 1) {\n        const singleOwner = singleContractOwnerDecode(data);\n        let obj = {\n            ownershipLevel: contract || 'registry',\n        };\n        if (contract === 'registrar') {\n            return {\n                ...obj,\n                registrant: singleOwner,\n            };\n        }\n        else {\n            return {\n                ...obj,\n                owner: singleOwner,\n            };\n        }\n    }\n    const result = await multicallWrapper.decode(data);\n    if (result === null)\n        return;\n    const nameWrapper = await contracts?.getNameWrapper();\n    const decodedData = [result[0][1], result[1][1], result[2]?.[1]].map((ret) => ret &&\n        ret !== '0x' &&\n        ethers.utils.defaultAbiCoder.decode(['address'], ret));\n    const registryOwner = decodedData[0][0];\n    const nameWrapperOwner = decodedData[1][0];\n    const registrarOwner = decodedData[2]?.[0];\n    // check for only .eth names\n    if (labels[labels.length - 1] === 'eth') {\n        // if the owner on the registrar is the namewrapper, then the namewrapper owner is the owner\n        // there is no \"registrant\" for wrapped names\n        if (registrarOwner === nameWrapper.address) {\n            return {\n                owner: nameWrapperOwner,\n                ownershipLevel: 'nameWrapper',\n            };\n        }\n        // if there is a registrar owner, then it's not a subdomain but we have also passed the namewrapper clause\n        // this means that it's an unwrapped second-level name\n        // the registrant is the owner of the NFT\n        // the owner is the controller of the records\n        if (registrarOwner) {\n            return {\n                registrant: registrarOwner,\n                owner: registryOwner,\n                ownershipLevel: 'registrar',\n            };\n        }\n        if (labels.length > 2 &&\n            ethers.utils.hexStripZeros(registryOwner) !== '0x') {\n            // this means that the subname is wrapped\n            if (registryOwner === nameWrapper.address) {\n                return {\n                    owner: nameWrapperOwner,\n                    ownershipLevel: 'nameWrapper',\n                };\n            }\n            // unwrapped subnames do not have NFTs associated, so do not have a registrant\n            return {\n                owner: registryOwner,\n                ownershipLevel: 'registry',\n            };\n        }\n        // .eth names with no registrar owner are either unregistered or expired\n        return;\n    }\n    // non .eth names inherit the owner from the registry\n    // there will only ever be an owner for non .eth names, not a registrant\n    // this is because for unwrapped names, there is no associated NFT\n    // and for wrapped names, owner and registrant are the same thing\n    if (registryOwner == nameWrapper.address) {\n        return {\n            owner: nameWrapperOwner,\n            ownershipLevel: 'nameWrapper',\n        };\n    }\n    // for unwrapped non .eth names, the owner is the registry owner\n    if (ethers.utils.hexStripZeros(registryOwner) !== '0x') {\n        return {\n            owner: registryOwner,\n            ownershipLevel: 'registry',\n        };\n    }\n    // for anything else, return\n    return;\n};\nexport default { raw, decode };\n"],"names":["singleContractOwnerRaw","contract","namehash","labels","contracts","getNameWrapper","nameWrapper","to","address","data","interface","encodeFunctionData","getRegistry","registry","getBaseRegistrar","registrar","labelhash","raw","name","multicallWrapper","makeNamehash","split","length","registryData","nameWrapperData","registrarData","push","singleContractOwnerDecode","ethers","decode","singleOwner","obj","ownershipLevel","registrant","owner","result","decodedData","map","ret","registryOwner","nameWrapperOwner","registrarOwner"],"sourceRoot":""}